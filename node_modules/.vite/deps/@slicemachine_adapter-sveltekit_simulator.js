import "./chunk-AYNHEKRI.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_element,
  claim_html_tag,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  noop,
  run_all,
  safe_not_equal,
  set_style,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-3XBAGWFC.js";
import "./chunk-2GBBIY5G.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports, module) {
    "use strict";
    var codes = require_codes();
    module.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        map[message.toLowerCase()] = status2;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status.message[code];
    }
    function status(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// node_modules/@prismicio/simulator/dist/lib/throttle.js
var throttle = (fn, delay = 16) => {
  let lastExec = 0;
  let timer = null;
  return function(...args) {
    const now = Date.now();
    const delta = now - lastExec;
    if (delta >= delay) {
      fn.apply(this, args);
      lastExec = now;
    } else {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        fn.apply(this, args);
        lastExec = Date.now();
      }, delay - delta);
    }
  };
};

// node_modules/@prismicio/simulator/dist/types.js
var APIRequestType;
(function(APIRequestType2) {
  APIRequestType2["SetActiveSlice"] = "setActiveSlice";
  APIRequestType2["SetSliceZoneSize"] = "setSliceZoneSize";
})(APIRequestType || (APIRequestType = {}));
var ClientRequestType;
(function(ClientRequestType2) {
  ClientRequestType2["Ping"] = "ping";
  ClientRequestType2["SetSliceZone"] = "setSliceZone";
  ClientRequestType2["ScrollToSlice"] = "scrollToSlice";
})(ClientRequestType || (ClientRequestType = {}));

// node_modules/@prismicio/simulator/dist/kit/types.js
var StateEventType;
(function(StateEventType2) {
  StateEventType2["Slices"] = "slices";
  StateEventType2["ActiveSlice"] = "activeSlice";
  StateEventType2["Message"] = "message";
})(StateEventType || (StateEventType = {}));

// node_modules/@prismicio/simulator/dist/SimulatorAPI.js
var import_statuses2 = __toESM(require_statuses(), 1);

// node_modules/@prismicio/simulator/dist/channel/types.js
var InternalEmitterRequestType;
(function(InternalEmitterRequestType2) {
  InternalEmitterRequestType2["Connect"] = "connect";
})(InternalEmitterRequestType || (InternalEmitterRequestType = {}));
var InternalReceiverRequestType;
(function(InternalReceiverRequestType2) {
  InternalReceiverRequestType2["Ready"] = "ready";
})(InternalReceiverRequestType || (InternalReceiverRequestType = {}));

// node_modules/@prismicio/simulator/dist/channel/errors.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(errorResponse) {
    super(errorResponse.msg);
    __publicField(this, "response");
    this.response = errorResponse;
  }
};
var TooManyConcurrentRequestsError = class extends Error {
  constructor(request) {
    super(`Too many concurrent requests`);
    __publicField(this, "request");
    this.request = request;
  }
};
var RequestTimeoutError = class extends Error {
  constructor(request) {
    super(`Request \`${request.requestID}\` timed out`);
    __publicField(this, "request");
    this.request = request;
  }
};
var NotReadyError = class extends Error {
};
var PortNotSetError = class extends Error {
  constructor() {
    super("Port is not set");
  }
};

// node_modules/@prismicio/simulator/dist/channel/messages.js
var import_statuses = __toESM(require_statuses(), 1);
var requestID = 0;
var createRequestMessage = (type, data, prefix = "") => {
  return {
    requestID: `${prefix}${requestID++}`,
    type,
    data
  };
};
var createSuccessResponseMessage = (requestID2, data, status = 200) => {
  var _a2;
  if (status >= 400) {
    throw new TypeError(`Invalid success status code, expected status to be within \`[100;400[\`, got \`${status}\``);
  }
  return {
    requestID: requestID2,
    status,
    msg: ((_a2 = import_statuses.default.message[status]) == null ? void 0 : _a2.replace(/\.$/, "").toLowerCase()) ?? "",
    data
  };
};
var createErrorResponseMessage = (requestID2, error, status = 400) => {
  var _a2;
  if (status < 400) {
    throw new TypeError(`Invalid error status code, expected status to be within \`[500;600[\`, got \`${status}\``);
  }
  return {
    requestID: requestID2,
    status,
    msg: ((_a2 = import_statuses.default.message[status]) == null ? void 0 : _a2.replace(/\.$/, "").toLowerCase()) ?? "",
    error
  };
};
var validateMessage = (message) => {
  if (typeof message !== "object" || message === null) {
    throw new TypeError(`Invalid message received, expected message to be of type \`object\`, got \`${typeof message}\``);
  } else if (!Object.keys(message).every((key) => ["requestID", "type", "data", "status", "msg", "error"].includes(key))) {
    throw new TypeError(`Invalid message received: ${JSON.stringify(message)}`);
  } else if (typeof message.requestID !== "string") {
    throw new TypeError(`Invalid message received, expected \`message.requestID\` to be of type \`string\`, got \`${typeof message.id}\``);
  }
  return message;
};
var isRequestMessage = (message) => {
  return "type" in message;
};
var isResponseMessage = (message) => {
  return !("type" in message);
};
var isSuccessResponseMessage = (message) => {
  return isResponseMessage(message) && !("error" in message);
};

// node_modules/@prismicio/simulator/dist/channel/ChannelNetwork.js
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var channelNetworkDefaultOptions = {
  debug: false,
  maximumRequestConcurrency: 20,
  defaultTimeout: 5e3,
  requestIDPrefix: "channel-"
};
var ChannelNetwork = class {
  constructor(requestHandlers, options) {
    __publicField2(this, "requestHandlers");
    __publicField2(this, "options");
    __publicField2(this, "_port", null);
    __publicField2(this, "_pendingRequests", /* @__PURE__ */ new Map());
    this.requestHandlers = requestHandlers;
    this.options = { ...channelNetworkDefaultOptions, ...options };
  }
  get port() {
    if (!this._port) {
      throw new PortNotSetError();
    }
    return this._port;
  }
  set port(port) {
    if (this._port) {
      this._port.onmessage = null;
    }
    this._port = port;
    if (this._port) {
      this._port.onmessage = this.onMessage.bind(this);
    }
  }
  createRequestMessage(type, data) {
    return createRequestMessage(type, data, this.options.requestIDPrefix);
  }
  async onMessage(event) {
    if (this.options.debug) {
      console.debug(event.data);
    }
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (!this.requestHandlers[message.type]) {
          this.postResponse(createErrorResponseMessage(message.requestID, void 0, 501));
        } else {
          try {
            const response = await this.requestHandlers[message.type](message, {
              success: createSuccessResponseMessage.bind(this, message.requestID),
              error: createErrorResponseMessage.bind(this, message.requestID)
            });
            this.postResponse(response);
          } catch (error) {
            this.postResponse(createErrorResponseMessage(message.requestID, error, 500));
          }
        }
      } else {
        if (!this._pendingRequests.has(message.requestID)) {
          console.error(`Unknown request ID received in response: ${JSON.stringify(message)}`);
        } else {
          this._pendingRequests.get(message.requestID)(message);
          this._pendingRequests.delete(message.requestID);
        }
      }
    } catch (error) {
      if (error instanceof TypeError) {
        console.warn(error.message);
      } else {
        throw error;
      }
    }
  }
  postRequest(request, postMessage = (request2) => this.port.postMessage(request2), options = {}) {
    if (this.options.debug) {
      console.debug(request);
    }
    if (this._pendingRequests.size >= this.options.maximumRequestConcurrency) {
      throw new TooManyConcurrentRequestsError(request);
    }
    return new Promise((resolve, reject) => {
      const requestTimeout = setTimeout(() => {
        if (this._pendingRequests.has(request.requestID)) {
          this._pendingRequests.delete(request.requestID);
        }
        reject(new RequestTimeoutError(request));
      }, options.timeout || this.options.defaultTimeout);
      this._pendingRequests.set(request.requestID, (response) => {
        clearTimeout(requestTimeout);
        isSuccessResponseMessage(response) ? resolve(response) : reject(new ResponseError(response));
      });
      postMessage(request);
    });
  }
  postResponse(response, postMessage = (response2) => this.port.postMessage(response2)) {
    if (this.options.debug) {
      console.debug(response);
    }
    postMessage(response);
    return response;
  }
};

// node_modules/@prismicio/simulator/dist/channel/ChannelReceiver.js
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var channelReceiverDefaultOptions = {
  readyTimeout: 2e4,
  requestIDPrefix: "receiver-"
};
var ChannelReceiver = class extends ChannelNetwork {
  constructor(requestHandlers, options) {
    super(requestHandlers, { ...channelReceiverDefaultOptions, ...options });
    __publicField3(this, "_ready", false);
    window.addEventListener("message", (event) => {
      this._onPublicMessage(event);
    });
  }
  /**
   * Tells the emitter that receiver is ready
   */
  async ready() {
    if (window.parent === window) {
      throw new Error("Receiver is currently not embedded as an iframe");
    }
    this._ready = false;
    const request = this.createRequestMessage(InternalReceiverRequestType.Ready, void 0);
    const response = await this.postRequest(request, (request2) => {
      window.parent.postMessage(request2, "*");
    }, {
      timeout: this.options.readyTimeout
    });
    this._ready = true;
    return response;
  }
  /**
   * Handles public messages
   */
  _onPublicMessage(event) {
    try {
      const message = validateMessage(event.data);
      if (isRequestMessage(message)) {
        if (this.options.debug) {
          console.debug(event.data);
        }
        switch (message.type) {
          case InternalEmitterRequestType.Connect:
            this.port = event.ports[0];
            const { data } = message;
            this.options = {
              ...this.options,
              ...data,
              // Ensure core options remain the same
              debug: this.options.debug,
              requestIDPrefix: this.options.requestIDPrefix,
              readyTimeout: this.options.readyTimeout
            };
            const response = createSuccessResponseMessage(message.requestID, void 0);
            this.postResponse(response);
            break;
          default:
            this.postResponse(createErrorResponseMessage(message.requestID, void 0), (response2) => {
              event.source.postMessage(response2, event.origin);
            });
            break;
        }
      } else {
        if (!this._ready) {
          this.onMessage(event);
        }
      }
    } catch (error) {
      if (error instanceof TypeError)
        ;
      else {
        throw error;
      }
    }
  }
  postFormattedRequest(type, data, options = {}) {
    if (!this._ready) {
      throw new NotReadyError("Receiver is not ready, use `ChannelReceiver.ready()` first");
    }
    return this.postRequest(this.createRequestMessage(type, data), void 0, options);
  }
};

// node_modules/@prismicio/simulator/dist/SimulatorAPI.js
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a;
var _b;
var simulatorAPIDefaultOptions = {
  requestIDPrefix: "api-",
  activeSliceAPI: false,
  sliceZoneSizeAPI: false
};
var SimulatorAPI = class extends ChannelReceiver {
  constructor(requestHandlers, options) {
    var _a2, _b2;
    const debug = (options == null ? void 0 : options.debug) || /[?&]debug=true/i.test(decodeURIComponent(window.location.search));
    super({
      [ClientRequestType.Ping]: (_req, res) => {
        return res.success("pong");
      },
      ...requestHandlers
    }, {
      ...simulatorAPIDefaultOptions,
      ...options,
      debug
    });
    __publicField4(this, _a, async (data) => {
      return await this.postFormattedRequest(APIRequestType.SetActiveSlice, data);
    });
    __publicField4(this, _b, async (data) => {
      return await this.postFormattedRequest(APIRequestType.SetSliceZoneSize, data);
    });
    if (debug) {
      window.prismic || (window.prismic = {});
      (_a2 = window.prismic).sliceSimulator || (_a2.sliceSimulator = {});
      (_b2 = window.prismic.sliceSimulator).api || (_b2.api = []);
      window.prismic.sliceSimulator.api.push(this);
    }
  }
};
_a = APIRequestType.SetActiveSlice, _b = APIRequestType.SetSliceZoneSize;

// node_modules/@prismicio/simulator/dist/kit/SimulatorManager.js
var import_statuses3 = __toESM(require_statuses(), 1);

// node_modules/@prismicio/simulator/dist/lib/EventEmitter.js
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var EventEmitter = class {
  constructor() {
    __publicField5(this, "_listeners", {});
  }
  on(event, listener, key = null) {
    this._listeners[event] = [
      ...this._listeners[event] ?? [],
      [listener, key]
    ];
  }
  off(event, listenerOrKey) {
    this._listeners[event] = (this._listeners[event] ?? []).filter(([listener, key]) => typeof listenerOrKey === "function" ? listener !== listenerOrKey : key !== listenerOrKey);
  }
  emit(event, payload) {
    (this._listeners[event] ?? []).forEach((listener) => listener[0](payload));
  }
};

// node_modules/@prismicio/simulator/dist/kit/domHelpers.js
var simulatorClass = "slice-simulator";
var simulatorRootClass = "slice-simulator--root";
var getSimulatorDOM = () => {
  return document.querySelector(`.${simulatorClass}`);
};
var getSimulatorRootDOM = () => {
  return document.querySelector(`.${simulatorRootClass}`);
};
var getSliceZoneDOM = (expectedNumberOfChildren) => {
  let node = document.querySelector(`.${simulatorClass} [data-slice-zone]`);
  if (node) {
    if (node.children.length !== expectedNumberOfChildren) {
      console.warn(`Flagged SliceZone has an unexpected number of children, found ${node.children.length} but expected ${expectedNumberOfChildren}. This might lead to unexpected behaviors. Are you sure you tagged the right element?`);
    }
    return node;
  }
  node = document.querySelector(`.${simulatorClass} .${simulatorRootClass}`);
  if (!node) {
    return null;
  }
  const searchDepth = 5;
  for (let i = 0; i < searchDepth; i++) {
    if (node.children.length === expectedNumberOfChildren) {
      return node;
    } else if (node.children.length) {
      node = node.children[0];
    } else {
      break;
    }
  }
  return null;
};
var getActiveSliceDOM = ($sliceZone, mouse) => {
  const raycast = document.elementsFromPoint(mouse.x, mouse.y).reverse();
  const sliceZoneIndex = raycast.indexOf($sliceZone);
  if (sliceZoneIndex === -1) {
    return null;
  }
  const $slice = raycast[sliceZoneIndex + 1];
  if (!$slice) {
    return null;
  }
  return $slice;
};

// node_modules/@prismicio/simulator/dist/kit/getDefault.js
var getDefaultProps = () => ({
  zIndex: 100,
  background: "#ffffff"
});
var getDefaultSlices = () => {
  return [];
};
var getDefaultMessage = () => {
  return "";
};

// node_modules/@prismicio/simulator/dist/kit/State.js
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => {
  __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var State = class extends EventEmitter {
  constructor(args) {
    super();
    __publicField6(this, "_slices");
    __publicField6(this, "_activeSlice");
    __publicField6(this, "_message");
    __publicField6(this, "_mouse");
    __publicField6(this, "_setActiveSlice", () => {
      if (this.slices.length === 0) {
        this.activeSlice = null;
        return;
      }
      const $sliceZone = getSliceZoneDOM(this.slices.length);
      if (!$sliceZone) {
        this.activeSlice = null;
        return;
      }
      const $activeSlice = getActiveSliceDOM($sliceZone, this._mouse);
      if (!$activeSlice) {
        this.activeSlice = null;
        return;
      }
      const activeSliceIndex = Array.prototype.indexOf.call($sliceZone.children, $activeSlice);
      this.activeSlice = {
        rect: $activeSlice.getBoundingClientRect(),
        sliceID: this.slices[activeSliceIndex].slice_type,
        variationID: this.slices[activeSliceIndex].variation,
        index: activeSliceIndex
      };
    });
    __publicField6(this, "setActiveSlice", throttle(this._setActiveSlice, 16));
    this._slices = (args == null ? void 0 : args.slices) || getDefaultSlices();
    this._activeSlice = null;
    this._message = "";
    this._mouse = { x: 0, y: 0 };
  }
  set slices(slices) {
    this._slices = slices;
    this.message = "";
    this.emit(StateEventType.Slices, slices);
  }
  get slices() {
    return this._slices;
  }
  set activeSlice(activeSlice) {
    this._activeSlice = activeSlice;
    this.emit(StateEventType.ActiveSlice, activeSlice);
  }
  get activeSlice() {
    return this._activeSlice;
  }
  set message(message) {
    this._message = message;
    this.emit(StateEventType.Message, message);
  }
  get message() {
    return this._message;
  }
  async init() {
    window.addEventListener("mousemove", (event) => {
      this._mouse = { x: event.clientX, y: event.clientY };
    });
  }
  setSliceZone(slices) {
    this.slices = slices;
  }
};

// node_modules/@prismicio/simulator/dist/kit/messages.js
var div = (content) => `<div style="word-spacing: initial; white-space: pre; line-height: initial; font-family: monospace; color: #ffffff; mix-blend-mode: difference; padding: 1rem; font-size: 1rem;">${content}</div>`;
var a = (href, label) => `<a href="${href}" style="text-decoration: underline;">${label || href}<a>`;
var header = "   _____ ___          _____ _                 __      __            \n  / ___// (_)_______ / ___/(_)___ ___  __  __/ /___ _/ /_____  _____\n  \\__ \\/ / / ___/ _ \\\\__ \\/ / __ `__ \\/ / / / / __ `/ __/ __ \\/ ___/\n ___/ / / / /__/  __/__/ / / / / / / / /_/ / / /_/ / /_/ /_/ / /    \n/____/_/_/\\___/\\___/____/_/_/ /_/ /_/\\__,_/_/\\__,_/\\__/\\____/_/     \n                  / /_  __  __   / __ \\_____(_)________ ___  (_)____\n                 / __ \\/ / / /  / /_/ / ___/ / ___/ __ `__ \\/ / ___/\n                / /_/ / /_/ /  / ____/ /  / (__  ) / / / / / / /__  \n               /_.___/\\__, /  /_/   /_/  /_/____/_/ /_/ /_/_/\\___/  \n                     /____/\n\n";
var footer = "\n\n\n\n\n\n                                                - The Prismic team";
var sliceSimulatorAccessedDirectly = div([
  header,
  `You're seeing this page because you're accessing Slice simulator
directly, e.g:

  - ${a("http://localhost:3000/slice-simulator")}



The Slice simulator can only be accessed through Slice Machine or the
Page Builder. To preview your Slices, head over to Slice Machine:

  - ${a("http://localhost:9999")}



If you believe this is an error, please reach out to us:

  - ${a("https://github.com/prismicio/slice-machine/issues/new/choose")}`,
  footer
].join(""));

// node_modules/@prismicio/simulator/dist/kit/SimulatorManager.js
var __defProp7 = Object.defineProperty;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField7 = (obj, key, value) => {
  __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var SimulatorManager = class {
  constructor(args) {
    __publicField7(this, "state");
    __publicField7(this, "_api");
    __publicField7(this, "_initialized");
    this.state = new State(args);
    this._api = null;
    this._initialized = false;
  }
  async init() {
    if (this._initialized) {
      return;
    } else {
      this._initialized = true;
    }
    await this.state.init();
    try {
      await this._initAPI();
    } catch (error) {
      if (error instanceof Error && error.message === "Receiver is currently not embedded as an iframe" && !this.state.slices.length) {
        this.state.message = sliceSimulatorAccessedDirectly;
      }
      console.error(error);
      return;
    }
    this._initListeners();
  }
  async _initAPI() {
    this._api = new SimulatorAPI({
      [ClientRequestType.SetSliceZone]: (req, res) => {
        this.state.setSliceZone(req.data);
        return res.success();
      },
      [ClientRequestType.ScrollToSlice]: (req, res) => {
        var _a2;
        if (req.data.sliceIndex < 0) {
          return res.error("`sliceIndex` must be > 0", 400);
        } else if (req.data.sliceIndex >= this.state.slices.length) {
          return res.error(`\`sliceIndex\` must be < ${this.state.slices.length} (\`<SliceZone />\` current length)`, 400);
        }
        const $sliceZone = getSliceZoneDOM(this.state.slices.length);
        if (!$sliceZone) {
          return res.error("Failed to find `<SliceZone />`", 500);
        }
        this.state.activeSlice = null;
        const $slice = $sliceZone.children[req.data.sliceIndex];
        if (!$slice) {
          return res.error(`Failed fo find slice at index $\`{req.data.sliceIndex}\` in \`<SliceZone />\``, 500);
        }
        $slice.scrollIntoView({
          behavior: req.data.behavior,
          block: req.data.block,
          inline: req.data.inline
        });
        ((_a2 = this._api) == null ? void 0 : _a2.options.activeSliceAPI) && setTimeout(this.state.setActiveSlice, 750);
        return res.success();
      }
    });
    await this._api.ready();
  }
  _initListeners() {
    var _a2, _b2;
    if ((_a2 = this._api) == null ? void 0 : _a2.options.activeSliceAPI) {
      window.addEventListener("mousemove", () => {
        this.state.setActiveSlice();
      });
      window.addEventListener("resize", () => {
        this.state.setActiveSlice();
      });
      window.addEventListener("mousewheel", () => {
        setTimeout(this.state.setActiveSlice, 200);
      });
      this.state.on(StateEventType.Slices, () => {
        this.state.setActiveSlice();
      });
      this.state.on(StateEventType.ActiveSlice, async (activeSlice) => {
        if (this._api) {
          try {
            await this._api.setActiveSlice(activeSlice);
          } catch (error) {
            if (error instanceof ResponseError && error.response.status === 400) {
              console.error(error.response);
            } else {
              throw error;
            }
          }
        }
      });
    }
    if ((_b2 = this._api) == null ? void 0 : _b2.options.sliceZoneSizeAPI) {
      const resizeObserver = new ResizeObserver(throttle(async (entries) => {
        const [entry] = entries;
        if (this._api && entry) {
          try {
            await this._api.setSliceZoneSize({ rect: entry.contentRect });
          } catch (error) {
            if (error instanceof ResponseError && error.response.status === 400) {
              console.error(error.response);
            } else {
              throw error;
            }
          }
        }
      }, 16));
      const observeSimulatorRoot = () => {
        const simulatorRootDOM = getSimulatorRootDOM();
        resizeObserver.disconnect();
        if (simulatorRootDOM) {
          resizeObserver.observe(simulatorRootDOM);
        }
      };
      const mutationObserver = new MutationObserver(observeSimulatorRoot);
      mutationObserver.observe(getSimulatorDOM(), {
        subtree: false,
        childList: true
      });
    }
  }
};

// node_modules/@prismicio/simulator/dist/kit/eventHandlers.js
var disableEventHandler = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
var onClickHandler = (event) => {
  if (event.path && event.path.slice(0, 5).some((el) => el instanceof HTMLAnchorElement)) {
    event.preventDefault();
    event.stopPropagation();
  }
};

// node_modules/@slicemachine/adapter-sveltekit/dist/simulator/SliceSimulator.svelte
var file = "node_modules/@slicemachine/adapter-sveltekit/dist/simulator/SliceSimulator.svelte";
var get_default_slot_changes = (dirty) => ({ slices: dirty & /*slices*/
4 });
var get_default_slot_context = (ctx) => ({ slices: (
  /*slices*/
  ctx[2]
) });
function create_if_block_1(ctx) {
  let div2;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      div2 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div2);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div2, "id", "root");
      attr_dev(div2, "class", simulatorRootClass);
      add_location(div2, file, 54, 2, 1232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div2, "click", onClickHandler, false, false, false, false),
          listen_dev(div2, "submit", disableEventHandler, false, false, false, false),
          listen_dev(div2, "keypress", disableEventHandler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slices*/
        36)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(53:25) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let article;
  let html_tag;
  const block = {
    c: function create() {
      article = element("article");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      article = claim_element(nodes, "ARTICLE", {});
      var article_nodes = children(article);
      html_tag = claim_html_tag(article_nodes, false);
      article_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      add_location(article, file, 48, 2, 1041);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, article, anchor);
      html_tag.m(
        /*message*/
        ctx[3],
        article
      );
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*message*/
      8) html_tag.p(
        /*message*/
        ctx2[3]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(article);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(48:1) {#if message}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*message*/
      ctx2[3]
    ) return 0;
    if (
      /*slices*/
      ctx2[2].length
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      if (if_block) if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div2, "class", div_class_value = simulatorClass + " " + /*$$props*/
      ctx[4].class);
      set_style(
        div2,
        "z-index",
        /*zIndex*/
        ctx[0]
      );
      set_style(div2, "position", "fixed");
      set_style(div2, "top", "0");
      set_style(div2, "left", "0");
      set_style(div2, "width", "100%");
      set_style(div2, "height", "100vh");
      set_style(div2, "overflow", "auto");
      set_style(
        div2,
        "background",
        /*background*/
        ctx[1]
      );
      add_location(div2, file, 43, 0, 844);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty & /*$$props*/
      16 && div_class_value !== (div_class_value = simulatorClass + " " + /*$$props*/
      ctx2[4].class)) {
        attr_dev(div2, "class", div_class_value);
      }
      if (!current || dirty & /*zIndex*/
      1) {
        set_style(
          div2,
          "z-index",
          /*zIndex*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*background*/
      2) {
        set_style(
          div2,
          "background",
          /*background*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliceSimulator", slots, ["default"]);
  const defaultProps = getDefaultProps();
  let { zIndex = defaultProps.zIndex } = $$props;
  let { background = defaultProps.background } = $$props;
  let slices = getDefaultSlices();
  let message = getDefaultMessage();
  if (typeof window !== "undefined") {
    const simulatorManager = new SimulatorManager();
    simulatorManager.state.on(
      StateEventType.Slices,
      (newSlices) => {
        $$invalidate(2, slices = newSlices);
      },
      "simulator-slices"
    );
    simulatorManager.state.on(
      StateEventType.Message,
      (newMessage) => {
        $$invalidate(3, message = newMessage);
      },
      "simulator-message"
    );
    simulatorManager.init();
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("zIndex" in $$new_props) $$invalidate(0, zIndex = $$new_props.zIndex);
    if ("background" in $$new_props) $$invalidate(1, background = $$new_props.background);
    if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    SimulatorManager,
    StateEventType,
    disableEventHandler,
    getDefaultMessage,
    getDefaultProps,
    getDefaultSlices,
    onClickHandler,
    simulatorClass,
    simulatorRootClass,
    defaultProps,
    zIndex,
    background,
    slices,
    message
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("zIndex" in $$props) $$invalidate(0, zIndex = $$new_props.zIndex);
    if ("background" in $$props) $$invalidate(1, background = $$new_props.background);
    if ("slices" in $$props) $$invalidate(2, slices = $$new_props.slices);
    if ("message" in $$props) $$invalidate(3, message = $$new_props.message);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [zIndex, background, slices, message, $$props, $$scope, slots];
}
var SliceSimulator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { zIndex: 0, background: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliceSimulator",
      options,
      id: create_fragment.name
    });
  }
  get zIndex() {
    throw new Error("<SliceSimulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<SliceSimulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<SliceSimulator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<SliceSimulator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliceSimulator_default = SliceSimulator;
export {
  SliceSimulator_default as SliceSimulator
};
/*! Bundled license information:

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=@slicemachine_adapter-sveltekit_simulator.js.map
