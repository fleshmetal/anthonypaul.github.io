import {
  __export
} from "./chunk-DC5AMYBS.js";

// node_modules/@prismicio/client/dist/types/value/richText.js
var RichTextNodeType = {
  heading1: "heading1",
  heading2: "heading2",
  heading3: "heading3",
  heading4: "heading4",
  heading5: "heading5",
  heading6: "heading6",
  paragraph: "paragraph",
  preformatted: "preformatted",
  strong: "strong",
  em: "em",
  listItem: "list-item",
  oListItem: "o-list-item",
  list: "group-list-item",
  oList: "group-o-list-item",
  image: "image",
  embed: "embed",
  hyperlink: "hyperlink",
  label: "label",
  span: "span"
};

// node_modules/@prismicio/client/dist/helpers/mapSliceZone.js
function mapSliceZone(sliceZone2, mappers, context) {
  return Promise.all(sliceZone2.map(async (slice, index, slices) => {
    const isRestSliceType = "slice_type" in slice;
    const sliceType = isRestSliceType ? slice.slice_type : slice.type;
    const mapper = mappers[sliceType];
    if (!mapper) {
      return slice;
    }
    const mapperArgs = { slice, slices, index, context };
    let result = await mapper(
      // @ts-expect-error - I don't know how to fix this type
      mapperArgs
    );
    if (
      // `mapper.length < 1` ensures the given
      // function is something of the form:
      // `() => import(...)`
      mapper.length < 1 && (typeof result === "function" || typeof result === "object" && "default" in result)
    ) {
      result = "default" in result ? result.default : result;
      result = await result(mapperArgs);
    }
    if (isRestSliceType) {
      return {
        __mapped: true,
        id: slice.id,
        slice_type: sliceType,
        ...result
      };
    } else {
      return {
        __mapped: true,
        type: sliceType,
        ...result
      };
    }
  }));
}

// node_modules/@prismicio/client/dist/filter.js
var formatValue = (value) => {
  if (Array.isArray(value)) {
    return `[${value.map(formatValue).join(", ")}]`;
  }
  if (typeof value === "string") {
    return `"${value}"`;
  }
  if (value instanceof Date) {
    return `${value.getTime()}`;
  }
  return `${value}`;
};
var pathWithArgsFilter = (name) => {
  const fn = (path, ...args) => {
    const formattedArgs = args.map(formatValue).join(", ");
    const joiner = path && args.length ? ", " : "";
    return `[${name}(${path}${joiner}${formattedArgs})]`;
  };
  return fn;
};
var pathFilter = (name) => {
  const filterFn = pathWithArgsFilter(name);
  const fn = (path) => {
    return filterFn(path);
  };
  return fn;
};
var argsFilter = (name) => {
  const filterFn = pathWithArgsFilter(name);
  const fn = (...args) => {
    return filterFn("", ...args);
  };
  return fn;
};
var filter = {
  /**
   * The `at` filter checks that the path matches the described value exactly.
   * It takes a single value for a field or an array (only for tags).
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#at}
   */
  at: pathWithArgsFilter("at"),
  /**
   * The `not` filter checks that the path doesn't match the provided value
   * exactly. It takes a single value for a field or an array (only for tags).
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#not}
   */
  not: pathWithArgsFilter("not"),
  /**
   * The `any` filter takes an array of values. It works exactly the same way as
   * the `at` operator, but checks whether the fragment matches any of the
   * values in the array.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#any}
   */
  any: pathWithArgsFilter("any"),
  /**
   * The `in` filter is used specifically to retrieve an array of documents by
   * their IDs or UIDs. This filter is much more efficient at this than the any
   * filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#in}
   */
  in: pathWithArgsFilter("in"),
  /**
   * The `fulltext` filter provides two capabilities:
   *
   * 1. Checking if a certain string is anywhere inside a document (this is what
   *    you should use to make your project's search engine feature)
   * 2. Checking if the string is contained inside a specific custom typeâ€™s Rich
   *    Text or Key Text fragment.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#fulltext}
   */
  fulltext: pathWithArgsFilter("fulltext"),
  /**
   * The `has` filter checks whether a fragment has a value. It will return all
   * the documents of the specified type that contain a value for the specified
   * field.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#has}
   */
  has: pathFilter("has"),
  /**
   * The `missing` filter checks if a fragment doesn't have a value. It will
   * return all the documents of the specified type that do not contain a value
   * for the specified field.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#missing}
   */
  missing: pathFilter("missing"),
  /**
   * The `similar` filter takes the ID of a document, and returns a list of
   * documents with similar content. This allows you to build an automated
   * content discovery feature (for example, a "Related posts" section).
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#similar}
   */
  similar: argsFilter("similar"),
  /**
   * The `geopoint.near` filter checks that the value in the path is within the
   * radius of the given coordinates.
   *
   * This filter will only work for a geopoint field.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#geopointnear}
   */
  geopointNear: pathWithArgsFilter("geopoint.near"),
  /**
   * The `number.lt` filter checks that the value in the number field is less
   * than the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#numberlessthan}
   */
  numberLessThan: pathWithArgsFilter("number.lt"),
  /**
   * The `number.gt` filter checks that the value in the number field is greater
   * than the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#numbergreaterthan}
   */
  numberGreaterThan: pathWithArgsFilter("number.gt"),
  /**
   * The `number.inRange` filter checks that the value in the path is within the
   * two values passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#numberinrange}
   */
  numberInRange: pathWithArgsFilter("number.inRange"),
  /**
   * The `date.after` filter checks that the value in the path is after the date
   * value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateAfter: pathWithArgsFilter("date.after"),
  /**
   * The `date.before` filter checks that the value in the path is before the
   * date value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateBefore: pathWithArgsFilter("date.before"),
  /**
   * The `date.between` filter checks that the value in the path is within the
   * date values passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateBetween: pathWithArgsFilter("date.between"),
  /**
   * The `date.day-of-month` filter checks that the value in the path is equal
   * to the day of the month passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfMonth: pathWithArgsFilter("date.day-of-month"),
  /**
   * The `date.day-of-month-after` filter checks that the value in the path is
   * after the day of the month passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfMonthAfter: pathWithArgsFilter("date.day-of-month-after"),
  /**
   * The `date.day-of-month-before` filter checks that the value in the path is
   * before the day of the month passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfMonthBefore: pathWithArgsFilter("date.day-of-month-before"),
  /**
   * The `date.day-of-week` filter checks that the value in the path is equal to
   * the day of the week passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfWeek: pathWithArgsFilter("date.day-of-week"),
  /**
   * The `date.day-of-week-after` filter checks that the value in the path is
   * after the day of the week passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfWeekAfter: pathWithArgsFilter("date.day-of-week-after"),
  /**
   * The date.day-of-week-before filter checks that the value in the path is
   * before the day of the week passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateDayOfWeekBefore: pathWithArgsFilter("date.day-of-week-before"),
  /**
   * The `date.month` filter checks that the value in the path occurs in the
   * month value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateMonth: pathWithArgsFilter("date.month"),
  /**
   * The `date.month-after` filter checks that the value in the path occurs in
   * any month after the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateMonthAfter: pathWithArgsFilter("date.month-after"),
  /**
   * The `date.month-before` filter checks that the value in the path occurs in
   * any month before the value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateMonthBefore: pathWithArgsFilter("date.month-before"),
  /**
   * The `date.year` filter checks that the value in the path occurs in the year
   * value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateYear: pathWithArgsFilter("date.year"),
  /**
   * The `date.hour` filter checks that the value in the path occurs within the
   * hour value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateHour: pathWithArgsFilter("date.hour"),
  /**
   * The `date.hour-after` filter checks that the value in the path occurs after
   * the hour value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateHourAfter: pathWithArgsFilter("date.hour-after"),
  /**
   * The `date.hour-before` filter checks that the value in the path occurs
   * before the hour value passed into the filter.
   *
   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}
   */
  dateHourBefore: pathWithArgsFilter("date.hour-before")
};

// node_modules/@prismicio/client/dist/lib/castArray.js
var castArray = (a) => {
  return Array.isArray(a) ? a : [a];
};

// node_modules/@prismicio/client/dist/lib/appendFilters.js
var appendFilters = (objWithFilters = {}, filters) => {
  return {
    ...objWithFilters,
    filters: [...objWithFilters.filters || [], ...castArray(filters)]
  };
};

// node_modules/@prismicio/client/dist/lib/castThunk.js
var castThunk = (a) => {
  return typeof a === "function" ? a : () => a;
};

// node_modules/@prismicio/client/dist/package.json.js
var version = "7.13.1";

// node_modules/@prismicio/client/dist/lib/devMsg.js
var devMsg = (slug) => {
  return `https://prismic.dev/msg/client/v${version}/${slug}`;
};

// node_modules/@prismicio/client/dist/lib/everyTagFilter.js
var everyTagFilter = (tags) => {
  return filter.at("document.tags", castArray(tags));
};

// node_modules/@prismicio/client/dist/errors/PrismicError.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var PrismicError = class extends Error {
  constructor(message = "An invalid API response was returned", url, response) {
    super(message);
    __publicField(this, "url");
    __publicField(this, "response");
    this.url = url;
    this.response = response;
  }
};

// node_modules/@prismicio/client/dist/lib/findRef.js
var findRef = (refs, filter2) => {
  const ref = refs.find((ref2) => filter2(ref2));
  if (!ref) {
    throw new PrismicError("Ref could not be found.", void 0, void 0);
  }
  return ref;
};

// node_modules/@prismicio/client/dist/lib/findMasterRef.js
var findMasterRef = (refs) => {
  return findRef(refs, (ref) => ref.isMasterRef);
};

// node_modules/@prismicio/client/dist/lib/findRefByID.js
var findRefByID = (refs, id) => {
  return findRef(refs, (ref) => ref.id === id);
};

// node_modules/@prismicio/client/dist/lib/findRefByLabel.js
var findRefByLabel = (refs, label) => {
  return findRef(refs, (ref) => ref.label === label);
};

// node_modules/@prismicio/client/dist/cookie.js
var cookie_exports = {};
__export(cookie_exports, {
  preview: () => preview
});
var preview = "io.prismic.preview";

// node_modules/@prismicio/client/dist/lib/getPreviewCookie.js
var readValue = (value) => {
  return value.replace(/%3B/g, ";");
};
var getPreviewCookie = (cookieJar) => {
  const cookies = cookieJar.split("; ");
  let value;
  for (const cookie of cookies) {
    const parts = cookie.split("=");
    const name = readValue(parts[0]).replace(/%3D/g, "=");
    if (name === preview) {
      value = readValue(parts.slice(1).join("="));
      break;
    }
  }
  return value;
};

// node_modules/@prismicio/client/dist/lib/minifyGraphQLQuery.js
var minifyGraphQLQuery = (query) => {
  return query.replace(/(\n| )*( |{|})(\n| )*/gm, (_chars, _spaces, brackets) => brackets);
};

// node_modules/@prismicio/client/dist/lib/someTagsFilter.js
var someTagsFilter = (tags) => {
  return filter.any("document.tags", castArray(tags));
};

// node_modules/@prismicio/client/dist/lib/typeFilter.js
var typeFilter = (documentType) => {
  return filter.at("document.type", documentType);
};

// node_modules/@prismicio/client/dist/errors/ForbiddenError.js
var ForbiddenError = class extends PrismicError {
};

// node_modules/@prismicio/client/dist/errors/NotFoundError.js
var NotFoundError = class extends PrismicError {
};

// node_modules/@prismicio/client/dist/errors/ParsingError.js
var ParsingError = class extends PrismicError {
};

// node_modules/@prismicio/client/dist/errors/PreviewTokenExpired.js
var PreviewTokenExpiredError = class extends ForbiddenError {
};

// node_modules/@prismicio/client/dist/errors/RefExpiredError.js
var RefExpiredError = class extends ForbiddenError {
};

// node_modules/@prismicio/client/dist/errors/RefNotFoundError.js
var RefNotFoundError = class extends ForbiddenError {
};

// node_modules/@prismicio/client/dist/errors/RepositoryNotFoundError.js
var RepositoryNotFoundError = class extends NotFoundError {
};

// node_modules/@prismicio/client/dist/types/value/link.js
var LinkType = {
  Any: "Any",
  Document: "Document",
  Media: "Media",
  Web: "Web"
};

// node_modules/@prismicio/client/dist/helpers/documentToLinkField.js
var documentToLinkField = (prismicDocument2) => {
  var _a;
  return {
    link_type: LinkType.Document,
    id: prismicDocument2.id,
    uid: prismicDocument2.uid || void 0,
    type: prismicDocument2.type,
    tags: prismicDocument2.tags,
    lang: prismicDocument2.lang,
    url: prismicDocument2.url == null ? void 0 : prismicDocument2.url,
    slug: (_a = prismicDocument2.slugs) == null ? void 0 : _a[0],
    // Slug field is not available with GraphQL
    // The REST API does not include a `data` property if the data
    // object is empty.
    //
    // A presence check for `prismicDocument.data` is done to
    // support partial documents. While `documentToLinkField` is
    // not typed to accept partial documents, passing a partial
    // document can happen in untyped projects.
    ...prismicDocument2.data && Object.keys(prismicDocument2.data).length > 0 ? { data: prismicDocument2.data } : {}
  };
};

// node_modules/@prismicio/client/dist/helpers/asLink.js
var asLink = (linkFieldOrDocument, ...configObjectOrTuple) => {
  if (!linkFieldOrDocument) {
    return null;
  }
  const linkField = (
    // prettier-ignore
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501
    // TODO: Remove the `prettier-ignore` comment when this bug is fixed.
    "link_type" in linkFieldOrDocument ? linkFieldOrDocument : documentToLinkField(linkFieldOrDocument)
  );
  const [configObjectOrLinkResolver] = configObjectOrTuple;
  let config;
  if (typeof configObjectOrLinkResolver === "function" || configObjectOrLinkResolver == null) {
    config = {
      linkResolver: configObjectOrLinkResolver
    };
  } else {
    config = { ...configObjectOrLinkResolver };
  }
  switch (linkField.link_type) {
    case LinkType.Media:
    case LinkType.Web:
      return "url" in linkField ? linkField.url : null;
    case LinkType.Document: {
      if ("id" in linkField && config.linkResolver) {
        const resolvedURL = config.linkResolver(linkField);
        if (resolvedURL != null) {
          return resolvedURL;
        }
      }
      if ("url" in linkField && linkField.url) {
        return linkField.url;
      }
      return null;
    }
    case LinkType.Any:
    default:
      return null;
  }
};

// node_modules/@prismicio/client/dist/lib/pLimit.js
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var pLimit = ({ interval } = {}) => {
  const queue = [];
  let busy = false;
  let lastCompletion = 0;
  const resumeNext = () => {
    var _a;
    if (!busy && queue.length > 0) {
      (_a = queue.shift()) == null ? void 0 : _a();
      busy = true;
    }
  };
  const next = () => {
    busy = false;
    resumeNext();
  };
  const run = async (function_, resolve, arguments_) => {
    const timeSinceLastCompletion = Date.now() - lastCompletion;
    if (interval && timeSinceLastCompletion < interval) {
      await sleep(interval - timeSinceLastCompletion);
    }
    const result = (async () => function_(...arguments_))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    lastCompletion = Date.now();
    next();
  };
  const enqueue = (function_, resolve, arguments_) => {
    new Promise((internalResolve) => {
      queue.push(internalResolve);
    }).then(run.bind(void 0, function_, resolve, arguments_));
    (async () => {
      await Promise.resolve();
      if (!busy) {
        resumeNext();
      }
    })();
  };
  return (function_, ...arguments_) => new Promise((resolve) => {
    enqueue(function_, resolve, arguments_);
  });
};

// node_modules/@prismicio/client/dist/BaseClient.js
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var UNKNOWN_RATE_LIMIT_DELAY = 1500;
var BaseClient = class {
  constructor(options) {
    __publicField2(this, "fetchFn");
    __publicField2(this, "fetchOptions");
    __publicField2(this, "queuedFetchJobs", {});
    __publicField2(this, "dedupedFetchJobs", {});
    this.fetchOptions = options.fetchOptions;
    if (typeof options.fetch === "function") {
      this.fetchFn = options.fetch;
    } else if (typeof globalThis.fetch === "function") {
      this.fetchFn = globalThis.fetch;
    } else {
      throw new PrismicError("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.", void 0, void 0);
    }
    if (this.fetchFn === globalThis.fetch) {
      this.fetchFn = this.fetchFn.bind(globalThis);
    }
  }
  async fetch(url, params = {}) {
    var _a, _b, _c, _d, _e;
    const requestInit = {
      ...this.fetchOptions,
      ...params.fetchOptions,
      headers: {
        ...(_a = this.fetchOptions) == null ? void 0 : _a.headers,
        ...(_b = params.fetchOptions) == null ? void 0 : _b.headers
      },
      signal: ((_c = params.fetchOptions) == null ? void 0 : _c.signal) || params.signal || ((_d = this.fetchOptions) == null ? void 0 : _d.signal)
    };
    if ((_e = params.fetchOptions) == null ? void 0 : _e.body) {
      return this.queueFetch(url, requestInit);
    } else {
      return this.dedupeFetch(url, requestInit);
    }
  }
  queueFetch(url, requestInit = {}) {
    const hostname = new URL(url).hostname;
    if (!this.queuedFetchJobs[hostname]) {
      this.queuedFetchJobs[hostname] = pLimit({
        interval: UNKNOWN_RATE_LIMIT_DELAY
      });
    }
    return this.queuedFetchJobs[hostname](() => this.createFetchJob(url, requestInit));
  }
  dedupeFetch(url, requestInit = {}) {
    let job;
    if (this.dedupedFetchJobs[url] && this.dedupedFetchJobs[url].has(requestInit.signal)) {
      job = this.dedupedFetchJobs[url].get(requestInit.signal);
    } else {
      this.dedupedFetchJobs[url] = this.dedupedFetchJobs[url] || /* @__PURE__ */ new Map();
      job = this.createFetchJob(url, requestInit).finally(() => {
        var _a, _b;
        (_a = this.dedupedFetchJobs[url]) == null ? void 0 : _a.delete(requestInit.signal);
        if (((_b = this.dedupedFetchJobs[url]) == null ? void 0 : _b.size) === 0) {
          delete this.dedupedFetchJobs[url];
        }
      });
      this.dedupedFetchJobs[url].set(requestInit.signal, job);
    }
    return job;
  }
  createFetchJob(url, requestInit = {}) {
    return this.fetchFn(url, requestInit).then(async (res) => {
      let json = void 0;
      let text = void 0;
      if (res.ok) {
        try {
          json = await res.json();
        } catch {
        }
      } else {
        try {
          text = await res.text();
          json = JSON.parse(text);
        } catch {
        }
      }
      return {
        status: res.status,
        headers: res.headers,
        json,
        text
      };
    });
  }
};

// node_modules/@prismicio/client/dist/buildQueryURL.js
var PRISMIC_DEV_PARAM = "x-d";
var PRISMIC_CLIENT_VERSION_PARAM = "x-c";
var RENAMED_PARAMS = {
  accessToken: "access_token"
};
var castOrderingToString = (ordering) => {
  if (typeof ordering === "string") {
    if (true) {
      const [field, direction] = ordering.split(" ");
      const objectForm = direction === "desc" ? `{ field: "${field}", direction: "desc" }` : `{ field: "${field}" }`;
      console.warn(`[@prismicio/client] A string value was provided to the \`orderings\` query parameter. Strings are deprecated. Please convert it to the object form: ${objectForm}. For more details, see ${devMsg("orderings-must-be-an-array-of-objects")}`);
    }
    return ordering;
  }
  return ordering.direction === "desc" ? `${ordering.field} desc` : ordering.field;
};
var buildQueryURL = (endpoint, args) => {
  const { filters, predicates, ...params } = args;
  const url = new URL(`documents/search`, `${endpoint}/`);
  if (filters) {
    if (!Array.isArray(filters)) {
      console.warn(`[@prismicio/client] A non-array value was provided to the \`filters\` query parameter (\`${filters}\`). Non-array values are deprecated. Please convert it to an array. For more details, see ${devMsg("filters-must-be-an-array")}`);
    }
    for (const filter2 of castArray(filters)) {
      url.searchParams.append("q", `[${filter2}]`);
    }
  }
  if (predicates) {
    for (const predicate2 of castArray(predicates)) {
      url.searchParams.append("q", `[${predicate2}]`);
    }
  }
  for (const k in params) {
    const name = RENAMED_PARAMS[k] || k;
    let value = params[k];
    if (name === "orderings") {
      const scopedValue = params[name];
      if (scopedValue != null) {
        if (typeof scopedValue === "string") {
          console.warn(`[@prismicio/client] A string value was provided to the \`orderings\` query parameter. Strings are deprecated. Please convert it to an array of objects. For more details, see ${devMsg("orderings-must-be-an-array-of-objects")}`);
        }
        const v = castArray(scopedValue).map((ordering) => castOrderingToString(ordering)).join(",");
        value = `[${v}]`;
      }
    } else if (name === "routes") {
      if (typeof params[name] === "object") {
        value = JSON.stringify(castArray(params[name]));
      }
    }
    if (value != null) {
      url.searchParams.set(name, castArray(value).join(","));
    }
  }
  url.searchParams.set(PRISMIC_CLIENT_VERSION_PARAM, `js-${version}`);
  if (true) {
    url.searchParams.set(PRISMIC_DEV_PARAM, "1");
  }
  return url.toString();
};

// node_modules/@prismicio/client/dist/isRepositoryName.js
var isRepositoryName = (input) => {
  return /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input);
};

// node_modules/@prismicio/client/dist/getRepositoryEndpoint.js
var getRepositoryEndpoint = (repositoryName) => {
  if (isRepositoryName(repositoryName)) {
    return `https://${repositoryName}.cdn.prismic.io/api/v2`;
  } else {
    throw new PrismicError(`An invalid Prismic repository name was given: ${repositoryName}`, void 0, void 0);
  }
};

// node_modules/@prismicio/client/dist/getRepositoryName.js
var getRepositoryName = (repositoryEndpoint) => {
  try {
    const hostname = new URL(repositoryEndpoint).hostname;
    if (hostname.endsWith("prismic.io") || // Production
    hostname.endsWith("wroom.io") || // Staging
    hostname.endsWith("wroom.test")) {
      return hostname.split(".")[0];
    }
  } catch {
  }
  throw new PrismicError(`An invalid Prismic Document API endpoint was provided: ${repositoryEndpoint}`, void 0, void 0);
};

// node_modules/@prismicio/client/dist/isRepositoryEndpoint.js
var isRepositoryEndpoint = (input) => {
  try {
    new URL(input);
    return true;
  } catch {
    return false;
  }
};

// node_modules/@prismicio/client/dist/Client.js
var __defProp3 = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _repositoryName;
var MAX_PAGE_SIZE = 100;
var REPOSITORY_CACHE_TTL = 5e3;
var GET_ALL_QUERY_DELAY = 500;
var DEFUALT_RETRY_AFTER_MS = 1e3;
var MAX_INVALID_REF_RETRY_ATTEMPS = 3;
var RefStateMode;
(function(RefStateMode2) {
  RefStateMode2["Master"] = "Master";
  RefStateMode2["ReleaseID"] = "ReleaseID";
  RefStateMode2["ReleaseLabel"] = "ReleaseLabel";
  RefStateMode2["Manual"] = "Manual";
})(RefStateMode || (RefStateMode = {}));
var Client = class extends BaseClient {
  /**
   * Creates a Prismic client that can be used to query a repository.
   *
   * If used in an environment where a global `fetch` function is unavailable,
   * such as in some Node.js versions, the `fetch` option must be provided as
   * part of the `options` parameter.
   *
   * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest
   *   API V2 endpoint for the repository.
   * @param options - Configuration that determines how content will be queried
   *   from the Prismic repository.
   *
   * @returns A client that can query content from the repository.
   */
  constructor(repositoryNameOrEndpoint, options = {}) {
    super(options);
    __privateAdd(this, _repositoryName);
    __publicField3(this, "documentAPIEndpoint");
    __publicField3(this, "accessToken");
    __publicField3(this, "routes");
    __publicField3(this, "brokenRoute");
    __publicField3(this, "defaultParams");
    __publicField3(this, "refState", {
      mode: RefStateMode.Master,
      autoPreviewsEnabled: true
    });
    __publicField3(this, "cachedRepository");
    __publicField3(this, "cachedRepositoryExpiration", 0);
    if ((options.documentAPIEndpoint || isRepositoryEndpoint(repositoryNameOrEndpoint)) && true) {
      const documentAPIEndpoint = options.documentAPIEndpoint || repositoryNameOrEndpoint;
      if (/\.prismic\.io\/(?!api\/v2\/?)/i.test(documentAPIEndpoint)) {
        throw new PrismicError("@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.", void 0, void 0);
      }
      const hostname = new URL(documentAPIEndpoint).hostname.toLowerCase();
      if (hostname.endsWith(".prismic.io") && !hostname.endsWith(".cdn.prismic.io")) {
        console.warn(`[@prismicio/client] The client was created with a non-CDN endpoint. Convert it to the CDN endpoint for better performance. For more details, see ${devMsg("endpoint-must-use-cdn")}`);
      }
      if (options.documentAPIEndpoint && isRepositoryEndpoint(repositoryNameOrEndpoint) && repositoryNameOrEndpoint !== options.documentAPIEndpoint) {
        console.warn(`[@prismicio/client] Multiple incompatible endpoints were provided. Create the client using a repository name to prevent this error. For more details, see ${devMsg("prefer-repository-name")}`);
      }
    }
    if (isRepositoryEndpoint(repositoryNameOrEndpoint)) {
      this.documentAPIEndpoint = repositoryNameOrEndpoint;
      try {
        this.repositoryName = getRepositoryName(repositoryNameOrEndpoint);
      } catch (error) {
        console.warn(`[@prismicio/client] A repository name could not be inferred from the provided endpoint (\`${repositoryNameOrEndpoint}\`). Some methods will be disabled. Create the client using a repository name to prevent this warning. For more details, see ${devMsg("prefer-repository-name")}`);
      }
    } else {
      this.documentAPIEndpoint = options.documentAPIEndpoint || getRepositoryEndpoint(repositoryNameOrEndpoint);
      this.repositoryName = repositoryNameOrEndpoint;
    }
    this.accessToken = options.accessToken;
    this.routes = options.routes;
    this.brokenRoute = options.brokenRoute;
    this.defaultParams = options.defaultParams;
    if (options.ref) {
      this.queryContentFromRef(options.ref);
    }
    this.graphQLFetch = this.graphQLFetch.bind(this);
  }
  /**
   * The Prismic repository's name.
   */
  set repositoryName(value) {
    __privateSet(this, _repositoryName, value);
  }
  /**
   * The Prismic repository's name.
   */
  get repositoryName() {
    if (!__privateGet(this, _repositoryName)) {
      throw new PrismicError(`A repository name is required for this method but one could not be inferred from the provided API endpoint (\`${this.documentAPIEndpoint}\`). To fix this error, provide a repository name when creating the client. For more details, see ${devMsg("prefer-repository-name")}`, void 0, void 0);
    }
    return __privateGet(this, _repositoryName);
  }
  /**
   * The Prismic REST API V2 endpoint for the repository (use
   * `prismic.getRepositoryEndpoint` for the default endpoint).
   *
   * @deprecated Use `documentAPIEndpoint` instead.
   */
  // TODO: Remove in v8.
  set endpoint(value) {
    this.documentAPIEndpoint = value;
  }
  /**
   * The Prismic REST API V2 endpoint for the repository (use
   * `prismic.getRepositoryEndpoint` for the default endpoint).
   *
   * @deprecated Use `documentAPIEndpoint` instead.
   */
  // TODO: Remove in v8.
  get endpoint() {
    return this.documentAPIEndpoint;
  }
  /**
   * Enables the client to automatically query content from a preview session if
   * one is active in browser environments. This is enabled by default in the
   * browser.
   *
   * For server environments, use `enableAutoPreviewsFromReq`.
   *
   * @example
   *
   * ```ts
   * client.enableAutoPreviews()
   * ```
   *
   * @see enableAutoPreviewsFromReq
   */
  enableAutoPreviews() {
    this.refState.autoPreviewsEnabled = true;
  }
  /**
   * Enables the client to automatically query content from a preview session if
   * one is active in server environments. This is disabled by default on the
   * server.
   *
   * For browser environments, use `enableAutoPreviews`.
   *
   * @example
   *
   * ```ts
   * // In an express app
   * app.get("/", function (req, res) {
   * 	client.enableAutoPreviewsFromReq(req)
   * })
   * ```
   *
   * @param req - An HTTP server request object containing the request's
   *   cookies.
   */
  enableAutoPreviewsFromReq(req) {
    this.refState.httpRequest = req;
    this.refState.autoPreviewsEnabled = true;
  }
  /**
   * Disables the client from automatically querying content from a preview
   * session if one is active.
   *
   * Automatic preview content querying is enabled by default unless this method
   * is called.
   *
   * @example
   *
   * ```ts
   * client.disableAutoPreviews()
   * ```
   */
  disableAutoPreviews() {
    this.refState.autoPreviewsEnabled = false;
  }
  /**
   * Queries content from the Prismic repository.
   *
   * @example
   *
   * ```ts
   * const response = await client.get()
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param params - Parameters to filter, sort, and paginate results.
   *
   * @returns A paginated response containing the result of the query.
   */
  async get(params) {
    const { data } = await this._get(params);
    return data;
  }
  /**
   * Queries content from the Prismic repository and returns only the first
   * result, if any.
   *
   * @example
   *
   * ```ts
   * const document = await client.getFirst()
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param params - Parameters to filter, sort, and paginate results.
   *
   * @returns The first result of the query, if any.
   */
  async getFirst(params) {
    var _a;
    const actualParams = { ...params };
    if (!(params && params.page) && !(params == null ? void 0 : params.pageSize)) {
      actualParams.pageSize = ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) ?? 1;
    }
    const { data, url } = await this._get(actualParams);
    const firstResult = data.results[0];
    if (firstResult) {
      return firstResult;
    }
    throw new NotFoundError("No documents were returned", url, void 0);
  }
  /**
   * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and
   * require more resources than other methods. Prefer using other methods that
   * filter by filters such as `getAllByType`.
   *
   * Queries content from the Prismic repository and returns all matching
   * content. If no filters are provided, all documents will be fetched.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.dangerouslyGetAll()
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param params - Parameters to filter, sort, and paginate results.
   *
   * @returns A list of documents matching the query.
   */
  async dangerouslyGetAll(params = {}) {
    var _a;
    const { limit = Infinity, ...actualParams } = params;
    const resolvedParams = {
      ...actualParams,
      pageSize: Math.min(limit, actualParams.pageSize || ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) || MAX_PAGE_SIZE)
    };
    const documents = [];
    let latestResult;
    while ((!latestResult || latestResult.next_page) && documents.length < limit) {
      const page = latestResult ? latestResult.page + 1 : void 0;
      latestResult = await this.get({ ...resolvedParams, page });
      documents.push(...latestResult.results);
      if (latestResult.next_page) {
        await new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));
      }
    }
    return documents.slice(0, limit);
  }
  /**
   * Queries a document from the Prismic repository with a specific ID.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   *
   * @example
   *
   * ```ts
   * const document = await client.getByID("WW4bKScAAMAqmluX")
   * ```
   *
   * @typeParam TDocument- Type of the Prismic document returned.
   *
   * @param id - ID of the document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns The document with an ID matching the `id` parameter, if a matching
   *   document exists.
   */
  async getByID(id, params) {
    return await this.getFirst(appendFilters(params, filter.at("document.id", id)));
  }
  /**
   * Queries documents from the Prismic repository with specific IDs.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByIDs([
   * 	"WW4bKScAAMAqmluX",
   * 	"U1kTRgEAAC8A5ldS",
   * ])
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param ids - A list of document IDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with IDs matching the
   *   `ids` parameter.
   */
  async getByIDs(ids, params) {
    return await this.get(appendFilters(params, filter.in("document.id", ids)));
  }
  /**
   * Queries all documents from the Prismic repository with specific IDs.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllByIDs([
   * 	"WW4bKScAAMAqmluX",
   * 	"U1kTRgEAAC8A5ldS",
   * ])
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param ids - A list of document IDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of documents with IDs matching the `ids` parameter.
   */
  async getAllByIDs(ids, params) {
    return await this.dangerouslyGetAll(appendFilters(params, filter.in("document.id", ids)));
  }
  /**
   * Queries a document from the Prismic repository with a specific UID and
   * custom type.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   *
   * @example
   *
   * ```ts
   * const document = await client.getByUID("blog_post", "my-first-post")
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param documentType - The API ID of the document's custom type.
   * @param uid - UID of the document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns The document with a UID matching the `uid` parameter, if a
   *   matching document exists.
   */
  async getByUID(documentType, uid, params) {
    return await this.getFirst(appendFilters(params, [
      typeFilter(documentType),
      filter.at(`my.${documentType}.uid`, uid)
    ]));
  }
  /**
   * Queries document from the Prismic repository with specific UIDs and Custom
   * Type.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   *
   * @example
   *
   * ```ts
   * const document = await client.getByUIDs("blog_post", [
   * 	"my-first-post",
   * 	"my-second-post",
   * ])
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param documentType - The API ID of the document's custom type.
   * @param uids - A list of document UIDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with UIDs matching the
   *   `uids` parameter.
   */
  async getByUIDs(documentType, uids, params) {
    return await this.get(appendFilters(params, [
      typeFilter(documentType),
      filter.in(`my.${documentType}.uid`, uids)
    ]));
  }
  /**
   * Queries all documents from the Prismic repository with specific UIDs and
   * custom type.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @remarks
   * A document's UID is different from its ID. An ID is automatically generated
   * for all documents and is made available on its `id` property. A UID is
   * provided in the Prismic editor and is unique among all documents of its
   * custom type.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllByUIDs([
   * 	"my-first-post",
   * 	"my-second-post",
   * ])
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param documentType - The API ID of the document's custom type.
   * @param uids - A list of document UIDs.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of documents with UIDs matching the `uids` parameter.
   */
  async getAllByUIDs(documentType, uids, params) {
    return await this.dangerouslyGetAll(appendFilters(params, [
      typeFilter(documentType),
      filter.in(`my.${documentType}.uid`, uids)
    ]));
  }
  /**
   * Queries a singleton document from the Prismic repository for a specific
   * custom type.
   *
   * @remarks
   * A singleton document is one that is configured in Prismic to only allow one
   * instance. For example, a repository may be configured to contain just one
   * Settings document. This is in contrast to a repeatable custom type which
   * allows multiple instances of itself.
   *
   * @example
   *
   * ```ts
   * const document = await client.getSingle("settings")
   * ```
   *
   * @typeParam TDocument - Type of the Prismic document returned.
   *
   * @param documentType - The API ID of the singleton custom type.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns The singleton document for the custom type, if a matching document
   *   exists.
   */
  async getSingle(documentType, params) {
    return await this.getFirst(appendFilters(params, typeFilter(documentType)));
  }
  /**
   * Queries documents from the Prismic repository for a specific custom type.
   *
   * Use `getAllByType` instead if you need to query all documents for a
   * specific custom type.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByType("blog_post")
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param documentType - The API ID of the custom type.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents of the custom type.
   */
  async getByType(documentType, params) {
    return await this.get(appendFilters(params, typeFilter(documentType)));
  }
  /**
   * Queries all documents from the Prismic repository for a specific Custom
   * Type.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByType("blog_post")
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param documentType - The API ID of the custom type.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents of the custom type.
   */
  async getAllByType(documentType, params) {
    return await this.dangerouslyGetAll(appendFilters(params, typeFilter(documentType)));
  }
  /**
   * Queries documents from the Prismic repository with a specific tag.
   *
   * Use `getAllByTag` instead if you need to query all documents with a
   * specific tag.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByTag("food")
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tag - The tag that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with the tag.
   */
  async getByTag(tag, params) {
    return await this.get(appendFilters(params, someTagsFilter(tag)));
  }
  /**
   * Queries all documents from the Prismic repository with a specific tag.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllByTag("food")
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tag - The tag that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents with the tag.
   */
  async getAllByTag(tag, params) {
    return await this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tag)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with all of the queried tags to be included.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByEveryTag(["food", "fruit"])
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with the tags.
   */
  async getByEveryTag(tags, params) {
    return await this.get(appendFilters(params, everyTagFilter(tags)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with all of the queried tags to be included.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllByEveryTag(["food", "fruit"])
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents with the tags.
   */
  async getAllByEveryTag(tags, params) {
    return await this.dangerouslyGetAll(appendFilters(params, everyTagFilter(tags)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with at least one of the queried tags to be
   * included.
   *
   * @example
   *
   * ```ts
   * const response = await client.getByEveryTag(["food", "fruit"])
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A paginated response containing documents with at least one of the
   *   tags.
   */
  async getBySomeTags(tags, params) {
    return await this.get(appendFilters(params, someTagsFilter(tags)));
  }
  /**
   * Queries documents from the Prismic repository with specific tags. A
   * document must be tagged with at least one of the queried tags to be
   * included.
   *
   * This method may make multiple network requests to query all matching
   * content.
   *
   * @example
   *
   * ```ts
   * const response = await client.getAllBySomeTags(["food", "fruit"])
   * ```
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param tags - A list of tags that must be included on a document.
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A list of all documents with at least one of the tags.
   */
  async getAllBySomeTags(tags, params) {
    return await this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tags)));
  }
  /**
   * Returns metadata about the Prismic repository, such as its refs, releases,
   * and custom types.
   *
   * @returns Repository metadata.
   */
  async getRepository(params) {
    const url = new URL(this.documentAPIEndpoint);
    if (this.accessToken) {
      url.searchParams.set("access_token", this.accessToken);
    }
    return await this.fetch(url.toString(), params);
  }
  /**
   * Returns a list of all refs for the Prismic repository.
   *
   * Refs are used to identify which version of the repository's content should
   * be queried. All repositories will have at least one ref pointing to the
   * latest published content called the "master ref".
   *
   * @returns A list of all refs for the Prismic repository.
   */
  async getRefs(params) {
    const repository = await this.getRepository(params);
    return repository.refs;
  }
  /**
   * Returns a ref for the Prismic repository with a matching ID.
   *
   * @param id - ID of the ref.
   *
   * @returns The ref with a matching ID, if it exists.
   */
  async getRefByID(id, params) {
    const refs = await this.getRefs(params);
    return findRefByID(refs, id);
  }
  /**
   * Returns a ref for the Prismic repository with a matching label.
   *
   * @param label - Label of the ref.
   *
   * @returns The ref with a matching label, if it exists.
   */
  async getRefByLabel(label, params) {
    const refs = await this.getRefs(params);
    return findRefByLabel(refs, label);
  }
  /**
   * Returns the master ref for the Prismic repository. The master ref points to
   * the repository's latest published content.
   *
   * @returns The repository's master ref.
   */
  async getMasterRef(params) {
    const refs = await this.getRefs(params);
    return findMasterRef(refs);
  }
  /**
   * Returns a list of all Releases for the Prismic repository. Releases are
   * used to group content changes before publishing.
   *
   * @returns A list of all Releases for the Prismic repository.
   */
  async getReleases(params) {
    const refs = await this.getRefs(params);
    return refs.filter((ref) => !ref.isMasterRef);
  }
  /**
   * Returns a Release for the Prismic repository with a matching ID.
   *
   * @param id - ID of the Release.
   *
   * @returns The Release with a matching ID, if it exists.
   */
  async getReleaseByID(id, params) {
    const releases = await this.getReleases(params);
    return findRefByID(releases, id);
  }
  /**
   * Returns a Release for the Prismic repository with a matching label.
   *
   * @param label - Label of the ref.
   *
   * @returns The ref with a matching label, if it exists.
   */
  async getReleaseByLabel(label, params) {
    const releases = await this.getReleases(params);
    return findRefByLabel(releases, label);
  }
  /**
   * Returns a list of all tags used in the Prismic repository.
   *
   * @returns A list of all tags used in the repository.
   */
  async getTags(params) {
    try {
      const tagsForm = await this.getCachedRepositoryForm("tags", params);
      const url = new URL(tagsForm.action);
      if (this.accessToken) {
        url.searchParams.set("access_token", this.accessToken);
      }
      return await this.fetch(url.toString(), params);
    } catch {
      const repository = await this.getRepository(params);
      return repository.tags;
    }
  }
  /**
   * Builds a URL used to query content from the Prismic repository.
   *
   * @param params - Parameters to filter, sort, and paginate the results.
   *
   * @returns A URL string that can be requested to query content.
   */
  async buildQueryURL({ signal, fetchOptions, ...params } = {}) {
    const ref = params.ref || await this.getResolvedRefString({ signal, fetchOptions });
    const integrationFieldsRef = params.integrationFieldsRef || (await this.getCachedRepository({ signal, fetchOptions })).integrationFieldsRef || void 0;
    return buildQueryURL(this.documentAPIEndpoint, {
      ...this.defaultParams,
      ...params,
      ref,
      integrationFieldsRef,
      routes: params.routes || this.routes,
      brokenRoute: params.brokenRoute || this.brokenRoute,
      accessToken: params.accessToken || this.accessToken
    });
  }
  /**
   * Determines the URL for a previewed document during an active preview
   * session. The result of this method should be used to redirect the user to
   * the document's URL.
   *
   * @example
   *
   * ```ts
   * 	const url = client.resolvePreviewURL({
   * 	linkResolver: (document) => `/${document.uid}`
   * 	defaultURL: '/'
   * 	})
   * ```
   *
   * @param args - Arguments to configure the URL resolving.
   *
   * @returns The URL for the previewed document during an active preview
   *   session. The user should be redirected to this URL.
   */
  async resolvePreviewURL(args) {
    var _a, _b;
    let documentID = args.documentID;
    let previewToken = args.previewToken;
    if (typeof globalThis.location !== "undefined") {
      const searchParams = new URLSearchParams(globalThis.location.search);
      documentID = documentID || searchParams.get("documentId");
      previewToken = previewToken || searchParams.get("token");
    } else if (this.refState.httpRequest) {
      if ("query" in this.refState.httpRequest) {
        documentID = documentID || ((_a = this.refState.httpRequest.query) == null ? void 0 : _a.documentId);
        previewToken = previewToken || ((_b = this.refState.httpRequest.query) == null ? void 0 : _b.token);
      } else if ("url" in this.refState.httpRequest && this.refState.httpRequest.url) {
        const searchParams = new URL(this.refState.httpRequest.url, "missing-host://").searchParams;
        documentID = documentID || searchParams.get("documentId");
        previewToken = previewToken || searchParams.get("token");
      }
    }
    if (documentID != null && previewToken != null) {
      const document = await this.getByID(documentID, {
        ref: previewToken,
        lang: "*",
        signal: args.signal,
        fetchOptions: args.fetchOptions
      });
      const url = asLink(document, { linkResolver: args.linkResolver });
      if (typeof url === "string") {
        return url;
      }
    }
    return args.defaultURL;
  }
  /**
   * Configures the client to query the latest published content for all future
   * queries.
   *
   * If the `ref` parameter is provided during a query, it takes priority for
   * that query.
   *
   * @example
   *
   * ```ts
   * await client.queryLatestContent()
   * const document = await client.getByID("WW4bKScAAMAqmluX")
   * ```
   */
  queryLatestContent() {
    this.refState.mode = RefStateMode.Master;
  }
  /**
   * Configures the client to query content from a specific Release identified
   * by its ID for all future queries.
   *
   * If the `ref` parameter is provided during a query, it takes priority for
   * that query.
   *
   * @example
   *
   * ```ts
   * await client.queryContentFromReleaseByID("YLB7OBAAACMA7Cpa")
   * const document = await client.getByID("WW4bKScAAMAqmluX")
   * ```
   *
   * @param releaseID - The ID of the Release.
   */
  queryContentFromReleaseByID(releaseID) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.ReleaseID,
      releaseID
    };
  }
  /**
   * Configures the client to query content from a specific Release identified
   * by its label for all future queries.
   *
   * If the `ref` parameter is provided during a query, it takes priority for
   * that query.
   *
   * @example
   *
   * ```ts
   * await client.queryContentFromReleaseByLabel("My Release")
   * const document = await client.getByID("WW4bKScAAMAqmluX")
   * ```
   *
   * @param releaseLabel - The label of the Release.
   */
  queryContentFromReleaseByLabel(releaseLabel) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.ReleaseLabel,
      releaseLabel
    };
  }
  /**
   * Configures the client to query content from a specific ref. The ref can be
   * provided as a string or a function.
   *
   * If a function is provided, the ref is fetched lazily before each query. The
   * function may also be asynchronous.
   *
   * @example
   *
   * ```ts
   * await client.queryContentFromRef("my-ref")
   * const document = await client.getByID("WW4bKScAAMAqmluX")
   * ```
   *
   * @param ref - The ref or a function that returns the ref from which to query
   *   content.
   */
  queryContentFromRef(ref) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.Manual,
      ref
    };
  }
  /**
   * A `fetch()` function to be used with GraphQL clients configured for
   * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`
   * and Authorization headers. Queries will automatically be minified by
   * removing whitespace where possible.
   *
   * @example
   *
   * ```ts
   * const graphQLClient = new ApolloClient({
   * 	link: new HttpLink({
   * 		uri: prismic.getGraphQLEndpoint(repositoryName),
   * 		// Provide `client.graphQLFetch` as the fetch implementation.
   * 		fetch: client.graphQLFetch,
   * 		// Using GET is required.
   * 		useGETForQueries: true,
   * 	}),
   * 	cache: new InMemoryCache(),
   * })
   * ```
   *
   * @param input - The `fetch()` `input` parameter. Only strings are supported.
   * @param init - The `fetch()` `init` parameter. Only plain objects are
   *   supported.
   *
   * @returns The `fetch()` Response for the request.
   *
   * @experimental
   */
  async graphQLFetch(input, init) {
    const cachedRepository = await this.getCachedRepository();
    const ref = await this.getResolvedRefString();
    const unsanitizedHeaders = {
      "Prismic-ref": ref,
      Authorization: this.accessToken ? `Token ${this.accessToken}` : "",
      // Asserting `init.headers` is a Record since popular GraphQL
      // libraries pass this as a Record. Header objects as input
      // are unsupported.
      ...init ? init.headers : {}
    };
    if (cachedRepository.integrationFieldsRef) {
      unsanitizedHeaders["Prismic-integration-field-ref"] = cachedRepository.integrationFieldsRef;
    }
    const headers = {};
    for (const key in unsanitizedHeaders) {
      if (unsanitizedHeaders[key]) {
        headers[key.toLowerCase()] = unsanitizedHeaders[key];
      }
    }
    const url = new URL(
      // Asserting `input` is a string since popular GraphQL
      // libraries pass this as a string. Request objects as
      // input are unsupported.
      input
    );
    url.searchParams.set("ref", ref);
    const query = url.searchParams.get("query");
    if (query) {
      url.searchParams.set(
        "query",
        // Compress the GraphQL query (if it exists) by
        // removing whitespace. This is done to
        // optimize the query size and avoid
        // hitting the upper limit of GET requests
        // (2048 characters).
        minifyGraphQLQuery(query)
      );
    }
    return await this.fetchFn(url.toString(), {
      ...init,
      headers
    });
  }
  /**
   * Returns a cached version of `getRepository` with a TTL.
   *
   * @returns Cached repository metadata.
   */
  async getCachedRepository(params) {
    if (!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration) {
      this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;
      this.cachedRepository = await this.getRepository(params);
    }
    return this.cachedRepository;
  }
  /**
   * Returns a cached Prismic repository form. Forms are used to determine API
   * endpoints for types of repository data.
   *
   * @param name - Name of the form.
   *
   * @returns The repository form.
   *
   * @throws If a matching form cannot be found.
   */
  async getCachedRepositoryForm(name, params) {
    const cachedRepository = await this.getCachedRepository(params);
    const form = cachedRepository.forms[name];
    if (!form) {
      throw new PrismicError(`Form with name "${name}" could not be found`, void 0, void 0);
    }
    return form;
  }
  /**
   * Returns the ref needed to query based on the client's current state. This
   * method may make a network request to fetch a ref or resolve the user's ref
   * thunk.
   *
   * If auto previews are enabled, the preview ref takes priority if available.
   *
   * The following strategies are used depending on the client's state:
   *
   * - If the user called `queryLatestContent`: Use the repository's master ref.
   *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is
   *   fetched.
   * - If the user called `queryContentFromReleaseByID`: Use the release's ref.
   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the
   *   release is fetched.
   * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.
   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the
   *   release is fetched.
   * - If the user called `queryContentFromRef`: Use the provided ref. Fall back
   *   to the master ref if the ref is not a string.
   *
   * @returns The ref to use during a query.
   */
  async getResolvedRefString(params) {
    var _a, _b;
    if (this.refState.autoPreviewsEnabled) {
      let previewRef;
      let cookieJar;
      if ((_a = this.refState.httpRequest) == null ? void 0 : _a.headers) {
        if ("get" in this.refState.httpRequest.headers && typeof this.refState.httpRequest.headers.get === "function") {
          cookieJar = this.refState.httpRequest.headers.get("cookie");
        } else if ("cookie" in this.refState.httpRequest.headers) {
          cookieJar = this.refState.httpRequest.headers.cookie;
        }
      } else if ((_b = globalThis.document) == null ? void 0 : _b.cookie) {
        cookieJar = globalThis.document.cookie;
      }
      if (cookieJar) {
        previewRef = getPreviewCookie(cookieJar);
      }
      if (previewRef) {
        return previewRef;
      }
    }
    const cachedRepository = await this.getCachedRepository(params);
    const refModeType = this.refState.mode;
    if (refModeType === RefStateMode.ReleaseID) {
      return findRefByID(cachedRepository.refs, this.refState.releaseID).ref;
    } else if (refModeType === RefStateMode.ReleaseLabel) {
      return findRefByLabel(cachedRepository.refs, this.refState.releaseLabel).ref;
    } else if (refModeType === RefStateMode.Manual) {
      const res = await castThunk(this.refState.ref)();
      if (typeof res === "string") {
        return res;
      }
    }
    return findMasterRef(cachedRepository.refs).ref;
  }
  /**
   * The private implementation of `this.get`. It returns the API response and
   * the URL used to make the request. The URL is sometimes used in the public
   * method to include in thrown errors.
   *
   * This method retries requests that throw `RefNotFoundError` or
   * `RefExpiredError`. It contains special logic to retry with the latest
   * master ref, provided in the API's error message.
   *
   * @typeParam TDocument - Type of Prismic documents returned.
   *
   * @param params - Parameters to filter, sort, and paginate results.
   *
   * @returns An object containing the paginated response containing the result
   *   of the query and the URL used to make the API request.
   */
  async _get(params, attemptCount = 0) {
    var _a, _b;
    const url = await this.buildQueryURL(params);
    try {
      const data = await this.fetch(url, params);
      return { data, url };
    } catch (error) {
      if (!(error instanceof RefNotFoundError || error instanceof RefExpiredError) || attemptCount >= MAX_INVALID_REF_RETRY_ATTEMPS - 1) {
        throw error;
      }
      if (!(params == null ? void 0 : params.ref)) {
        this.cachedRepository = void 0;
      }
      const masterRef = (_b = (_a = error.message.match(/Master ref is: (?<ref>.*)$/)) == null ? void 0 : _a.groups) == null ? void 0 : _b.ref;
      if (!masterRef) {
        throw error;
      }
      const badRef = new URL(url).searchParams.get("ref");
      const issue = error instanceof RefNotFoundError ? "invalid" : "expired";
      console.warn(`The ref (${badRef}) was ${issue}. Now retrying with the latest master ref (${masterRef}). If you were previewing content, the response will not include draft content.`);
      return await this._get({ ...params, ref: masterRef }, attemptCount + 1);
    }
  }
  /**
   * Performs a network request using the configured `fetch` function. It
   * assumes all successful responses will have a JSON content type. It also
   * normalizes unsuccessful network requests.
   *
   * @typeParam T - The JSON response.
   *
   * @param url - URL to the resource to fetch.
   * @param params - Prismic REST API parameters for the network request.
   *
   * @returns The JSON response from the network request.
   */
  async fetch(url, params = {}) {
    const res = await super.fetch(url, params);
    if (res.status !== 404 && res.status !== 429 && res.json == null) {
      throw new PrismicError(void 0, url, res.json || res.text);
    }
    switch (res.status) {
      case 200:
      case 201: {
        return res.json;
      }
      case 400: {
        throw new ParsingError(res.json.message, url, res.json);
      }
      case 401:
      case 403: {
        throw new ForbiddenError(res.json.error || res.json.message, url, res.json);
      }
      case 404: {
        if (res.json === void 0) {
          throw new RepositoryNotFoundError(`Prismic repository not found. Check that "${this.documentAPIEndpoint}" is pointing to the correct repository.`, url, url.startsWith(this.documentAPIEndpoint) ? void 0 : res.text);
        }
        if (res.json.type === "api_notfound_error") {
          throw new RefNotFoundError(res.json.message, url, res.json);
        }
        if (res.json.type === "api_security_error" && /preview token.*expired/i.test(res.json.message)) {
          throw new PreviewTokenExpiredError(res.json.message, url, res.json);
        }
        throw new NotFoundError(res.json.message, url, res.json);
      }
      case 410: {
        throw new RefExpiredError(res.json.message, url, res.json);
      }
      case 429: {
        const parsedRetryAfter = Number(res.headers.get("retry-after"));
        const delay = Number.isNaN(parsedRetryAfter) ? DEFUALT_RETRY_AFTER_MS : parsedRetryAfter;
        return await new Promise((resolve, reject) => {
          setTimeout(async () => {
            try {
              resolve(await this.fetch(url, params));
            } catch (error) {
              reject(error);
            }
          }, delay);
        });
      }
    }
    throw new PrismicError(void 0, url, res.json);
  }
};
_repositoryName = /* @__PURE__ */ new WeakMap();

// node_modules/@prismicio/client/dist/createClient.js
var createClient = (repositoryNameOrEndpoint, options) => new Client(repositoryNameOrEndpoint, options);

// node_modules/@prismicio/client/dist/types/migration/Asset.js
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var PrismicMigrationAsset = class {
  /**
   * Creates a migration asset used with the Prismic Migration API.
   *
   * @param config - Configuration of the asset.
   * @param initialField - The initial field value if any.
   *
   * @returns A migration asset instance.
   */
  constructor(config, initialField) {
    __publicField4(this, "asset");
    __publicField4(this, "config");
    __publicField4(this, "originalField");
    this.config = config;
    this.originalField = initialField;
  }
};

// node_modules/@prismicio/client/dist/types/migration/Document.js
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
var PrismicMigrationDocument = class {
  /**
   * Creates a Prismic migration document instance.
   *
   * @param document - The document to be sent to the Migration API.
   * @param title - The name of the document displayed in the editor.
   * @param params - Parameters to create/update the document with on the
   *   Migration API.
   *
   * @returns A Prismic migration document instance.
   */
  constructor(document, title2, params) {
    __publicField5(this, "document");
    __publicField5(this, "title");
    __publicField5(this, "masterLanguageDocument");
    __publicField5(this, "originalPrismicDocument");
    this.document = document;
    this.title = title2;
    this.masterLanguageDocument = params == null ? void 0 : params.masterLanguageDocument;
    this.originalPrismicDocument = params == null ? void 0 : params.originalPrismicDocument;
  }
};

// node_modules/@prismicio/client/dist/helpers/isFilled.js
var isFilled_exports = {};
__export(isFilled_exports, {
  color: () => color,
  contentRelationship: () => contentRelationship,
  date: () => date,
  embed: () => embed,
  geoPoint: () => geoPoint,
  group: () => group,
  image: () => image,
  imageThumbnail: () => imageThumbnail,
  integrationField: () => integrationField,
  integrationFields: () => integrationFields,
  keyText: () => keyText,
  link: () => link,
  linkToMedia: () => linkToMedia,
  number: () => number,
  repeatable: () => repeatable,
  richText: () => richText,
  select: () => select,
  sliceZone: () => sliceZone,
  timestamp: () => timestamp,
  title: () => title
});
var isNonNullish = (input) => {
  return input != null;
};
var isNonEmptyArray = (input) => {
  return !!input.length;
};
var richText = (field) => {
  if (!isNonNullish(field)) {
    return false;
  } else if (field.length === 1 && "text" in field[0]) {
    return !!field[0].text;
  } else {
    return !!field.length;
  }
};
var title = richText;
var imageThumbnail = (thumbnail) => {
  return isNonNullish(thumbnail) && !!thumbnail.url;
};
var image = imageThumbnail;
var link = (field) => {
  return isNonNullish(field) && ("id" in field || "url" in field);
};
var linkToMedia = link;
var contentRelationship = link;
var date = isNonNullish;
var timestamp = isNonNullish;
var color = isNonNullish;
var number = isNonNullish;
var keyText = (field) => {
  return isNonNullish(keyText) && !!field;
};
var select = isNonNullish;
var embed = (field) => {
  return isNonNullish(field) && !!field.embed_url;
};
var geoPoint = (field) => {
  return isNonNullish(field) && "longitude" in field;
};
var integrationField = isNonNullish;
var integrationFields = integrationField;
var repeatable = (repeatable2) => {
  return isNonNullish(repeatable2) && isNonEmptyArray(repeatable2);
};
var group = (group2) => {
  return isNonNullish(group2) && isNonEmptyArray(group2);
};
var sliceZone = (slices) => {
  return isNonNullish(slices) && isNonEmptyArray(slices);
};

// node_modules/@prismicio/client/dist/lib/isValue.js
var filledLinkToMedia = (value) => {
  if (value && typeof value === "object" && !("version" in value)) {
    if ("link_type" in value && value.link_type === LinkType.Media && "id" in value && "name" in value && "kind" in value && "url" in value && "size" in value) {
      return true;
    }
  }
  return false;
};
var imageLike = (value) => {
  if (value && typeof value === "object" && (!("version" in value) || typeof value.version === "object")) {
    if ("id" in value && "url" in value && typeof value.url === "string" && "dimensions" in value && "edit" in value && "alt" in value && "copyright" in value) {
      return true;
    }
  }
  return false;
};
var filledImage = (value) => {
  if (imageLike(value) && (!("type" in value) || value.type !== RichTextNodeType.image)) {
    return true;
  }
  return false;
};
var rtImageNode = (value) => {
  if (imageLike(value) && "type" in value && value.type === RichTextNodeType.image) {
    return true;
  }
  return false;
};
var filledContentRelationship = (value) => {
  if (value && typeof value === "object" && !("version" in value)) {
    if ("link_type" in value && value.link_type === LinkType.Document && "id" in value && "type" in value && "tags" in value && "lang" in value) {
      return true;
    }
  }
  return false;
};
var prismicDocument = (value) => {
  try {
    return typeof value === "object" && value !== null && "id" in value && "href" in value && typeof value.href === "string" && new URL(value.href) && "type" in value && "lang" in value && "tags" in value && Array.isArray(value.tags);
  } catch {
    return false;
  }
};

// node_modules/@prismicio/client/dist/lib/isMigrationValue.js
var contentRelationship2 = (value) => {
  return value instanceof PrismicMigrationDocument || prismicDocument(value) || typeof value === "object" && value !== null && "link_type" in value && value.link_type === LinkType.Document && "id" in value && (contentRelationship2(value.id) || typeof value.id === "function");
};
var image2 = (value) => {
  return value instanceof PrismicMigrationAsset || typeof value === "object" && value !== null && "id" in value && Object.values(value).every((maybeThumbnail) => maybeThumbnail instanceof PrismicMigrationAsset);
};
var linkToMedia2 = (value) => {
  return typeof value === "object" && value !== null && "id" in value && value.id instanceof PrismicMigrationAsset && "link_type" in value && value.link_type === LinkType.Media;
};
var rtImageNode2 = (value) => {
  return typeof value === "object" && value !== null && "id" in value && value.id instanceof PrismicMigrationAsset && "type" in value && value.type === RichTextNodeType.image;
};

// node_modules/@prismicio/client/dist/lib/resolveMigrationDocumentData.js
async function resolveMigrationContentRelationship(relation) {
  if (typeof relation === "function") {
    return resolveMigrationContentRelationship(await relation());
  }
  if (relation instanceof PrismicMigrationDocument) {
    return relation.document.id ? { link_type: LinkType.Document, id: relation.document.id } : { link_type: LinkType.Document };
  }
  if (relation) {
    if (contentRelationship2(relation.id) || typeof relation.id === "function") {
      return {
        ...await resolveMigrationContentRelationship(relation.id),
        // TODO: Remove when link text PR is merged
        // @ts-expect-error - Future-proofing for link text
        text: relation.text
      };
    }
    return { link_type: LinkType.Document, id: relation.id };
  }
  return { link_type: LinkType.Document };
}
var resolveMigrationImage = (image22, migration, withThumbnails) => {
  var _a;
  const { id: master, ...thumbnails } = image22 instanceof PrismicMigrationAsset ? { id: image22 } : image22;
  const asset = (_a = migration._assets.get(master.config.id)) == null ? void 0 : _a.asset;
  const maybeInitialField = master.originalField;
  if (asset) {
    const parameters = ((maybeInitialField == null ? void 0 : maybeInitialField.url) || asset.url).split("?")[1];
    const url = `${asset.url.split("?")[0]}${parameters ? `?${parameters}` : ""}`;
    const dimensions = {
      width: asset.width,
      height: asset.height
    };
    const edit = maybeInitialField && "edit" in maybeInitialField ? maybeInitialField == null ? void 0 : maybeInitialField.edit : { x: 0, y: 0, zoom: 1, background: "transparent" };
    const alt = master.config.alt || asset.alt || null;
    const resolvedThumbnails = {};
    if (withThumbnails) {
      for (const [name, thumbnail] of Object.entries(thumbnails)) {
        const resolvedThumbnail = resolveMigrationImage(thumbnail, migration);
        if (resolvedThumbnail) {
          resolvedThumbnails[name] = resolvedThumbnail;
        }
      }
    }
    return {
      id: asset.id,
      url,
      dimensions,
      edit,
      alt,
      copyright: asset.credits || null,
      ...resolvedThumbnails
    };
  }
};
var resolveMigrationRTImageNode = async (rtImageNode22, migration) => {
  const image22 = resolveMigrationImage(rtImageNode22.id, migration);
  if (image22) {
    const linkTo = await resolveMigrationDocumentData(rtImageNode22.linkTo, migration);
    return {
      ...image22,
      type: RichTextNodeType.image,
      linkTo: link(linkTo) ? linkTo : void 0
    };
  }
};
var resolveMigrationLinkToMedia = (linkToMedia22, migration) => {
  var _a;
  const asset = (_a = migration._assets.get(linkToMedia22.id.config.id)) == null ? void 0 : _a.asset;
  if (asset) {
    return {
      id: asset.id,
      link_type: LinkType.Media,
      text: linkToMedia22.text
    };
  }
  return { link_type: LinkType.Media };
};
async function resolveMigrationDocumentData(input, migration) {
  if (contentRelationship2(input)) {
    return resolveMigrationContentRelationship(input);
  }
  if (image2(input)) {
    return resolveMigrationImage(input, migration, true);
  }
  if (linkToMedia2(input)) {
    return resolveMigrationLinkToMedia(input, migration);
  }
  if (rtImageNode2(input)) {
    return resolveMigrationRTImageNode(input, migration);
  }
  if (typeof input === "function") {
    return await resolveMigrationDocumentData(await input(), migration);
  }
  if (Array.isArray(input)) {
    const res = [];
    for (const element of input) {
      res.push(await resolveMigrationDocumentData(element, migration));
    }
    return res.filter(Boolean);
  }
  if (input && typeof input === "object") {
    const res = {};
    for (const key in input) {
      res[key] = await resolveMigrationDocumentData(input[key], migration);
    }
    return res;
  }
  return input;
}

// node_modules/@prismicio/client/dist/WriteClient.js
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
var MIGRATION_API_DEMO_KEYS = [
  "cSaZlfkQlF9C6CEAM2Del6MNX9WonlV86HPbeEJL",
  "pZCexCajUQ4jriYwIGSxA1drZrFxDyFf1S0D1K0P",
  "Yc0mfrkGDw8gaaGKTrzwC3QUZDajv6k73DA99vWN",
  "ySzSEbVMAb5S1oSCQfbVG4mbh9Cb8wlF7BCvKI0L",
  "g2DA3EKWvx8uxVYcNFrmT5nJpon1Vi9V4XcOibJD",
  "CCNIlI0Vz41J66oFwsHUXaZa6NYFIY6z7aDF62Bc"
];
var WriteClient = class extends Client {
  /**
   * Creates a Prismic client that can be used to query and write content to a
   * repository.
   *
   * If used in an environment where a global `fetch` function is unavailable,
   * such as in some Node.js versions, the `fetch` option must be provided as
   * part of the `options` parameter.
   *
   * @param repositoryName - The Prismic repository name for the repository.
   * @param options - Configuration that determines how content will be queried
   *   from and written to the Prismic repository.
   *
   * @returns A client that can query and write content to the repository.
   */
  constructor(repositoryName, options) {
    super(repositoryName, options);
    __publicField6(this, "writeToken");
    __publicField6(this, "migrationAPIKey");
    __publicField6(this, "assetAPIEndpoint", "https://asset-api.prismic.io/");
    __publicField6(this, "migrationAPIEndpoint", "https://migration.prismic.io/");
    __publicField6(this, "_resolveAssetTagIDsLimit", pLimit());
    if (typeof globalThis.window !== "undefined") {
      console.warn(`[@prismicio/client] Prismic write client appears to be running in a browser environment. This is not recommended as it exposes your write token and Migration API key. Consider using Prismic write client in a server environment only, preferring the regular client for browser environement. For more details, see ${devMsg("avoid-write-client-in-browser")}`);
    }
    this.writeToken = options.writeToken;
    this.migrationAPIKey = options.migrationAPIKey || MIGRATION_API_DEMO_KEYS[Math.floor(Math.random() * MIGRATION_API_DEMO_KEYS.length)];
    if (options.assetAPIEndpoint) {
      this.assetAPIEndpoint = `${options.assetAPIEndpoint}/`;
    }
    if (options.migrationAPIEndpoint) {
      this.migrationAPIEndpoint = `${options.migrationAPIEndpoint}/`;
    }
  }
  /**
   * Creates a migration release on the Prismic repository based on the provided
   * prepared migration.
   *
   * @param migration - A migration prepared with {@link createMigration}.
   * @param params - An event listener and additional fetch parameters.
   *
   * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}
   */
  async migrate(migration, params = {}) {
    var _a, _b;
    (_a = params.reporter) == null ? void 0 : _a.call(params, {
      type: "start",
      data: {
        pending: {
          documents: migration._documents.length,
          assets: migration._assets.size
        }
      }
    });
    await this.migrateCreateAssets(migration, params);
    await this.migrateCreateDocuments(migration, params);
    await this.migrateUpdateDocuments(migration, params);
    (_b = params.reporter) == null ? void 0 : _b.call(params, {
      type: "end",
      data: {
        migrated: {
          documents: migration._documents.length,
          assets: migration._assets.size
        }
      }
    });
  }
  /**
   * Creates assets in the Prismic repository's media library.
   *
   * @param migration - A migration prepared with {@link createMigration}.
   * @param params - An event listener and additional fetch parameters.
   *
   * @internal This method is one of the step performed by the {@link migrate} method.
   */
  async migrateCreateAssets(migration, { reporter, ...fetchParams } = {}) {
    let created = 0;
    for (const [_, migrationAsset] of migration._assets) {
      reporter == null ? void 0 : reporter({
        type: "assets:creating",
        data: {
          current: ++created,
          remaining: migration._assets.size - created,
          total: migration._assets.size,
          asset: migrationAsset
        }
      });
      const { file, filename, notes, credits, alt, tags } = migrationAsset.config;
      let resolvedFile;
      if (typeof file === "string") {
        let url;
        try {
          url = new URL(file);
        } catch (error) {
        }
        if (url) {
          resolvedFile = await this.fetchForeignAsset(url.toString(), fetchParams);
        } else {
          resolvedFile = file;
        }
      } else if (file instanceof URL) {
        resolvedFile = await this.fetchForeignAsset(file.toString(), fetchParams);
      } else {
        resolvedFile = file;
      }
      const asset = await this.createAsset(resolvedFile, filename, {
        ...{ notes, credits, alt, tags },
        ...fetchParams
      });
      migrationAsset.asset = asset;
    }
    reporter == null ? void 0 : reporter({
      type: "assets:created",
      data: {
        created
      }
    });
  }
  /**
   * Creates documents in the Prismic repository's migration release.
   *
   * @param migration - A migration prepared with {@link createMigration}.
   * @param params - An event listener and additional fetch parameters.
   *
   * @internal This method is one of the step performed by the {@link migrate} method.
   */
  async migrateCreateDocuments(migration, { reporter, ...fetchParams } = {}) {
    var _a, _b;
    const repository = await this.getRepository(fetchParams);
    const masterLocale = repository.languages.find((lang) => lang.is_master).id;
    reporter == null ? void 0 : reporter({
      type: "documents:masterLocale",
      data: {
        masterLocale
      }
    });
    const documentsToCreate = [];
    for (const doc of migration._documents) {
      if (!doc.document.id) {
        if (doc.document.lang === masterLocale) {
          documentsToCreate.unshift(doc);
        } else {
          documentsToCreate.push(doc);
        }
      }
    }
    let created = 0;
    for (const doc of documentsToCreate) {
      reporter == null ? void 0 : reporter({
        type: "documents:creating",
        data: {
          current: ++created,
          remaining: documentsToCreate.length - created,
          total: documentsToCreate.length,
          document: doc
        }
      });
      let masterLanguageDocumentID;
      if (doc.masterLanguageDocument) {
        const masterLanguageDocument = await resolveMigrationContentRelationship(doc.masterLanguageDocument);
        masterLanguageDocumentID = "id" in masterLanguageDocument ? masterLanguageDocument.id : void 0;
      } else if (doc.originalPrismicDocument) {
        const maybeOriginalID = (_a = doc.originalPrismicDocument.alternate_languages.find(({ lang }) => lang === masterLocale)) == null ? void 0 : _a.id;
        if (maybeOriginalID) {
          masterLanguageDocumentID = (_b = migration._getByOriginalID(maybeOriginalID)) == null ? void 0 : _b.document.id;
        }
      }
      const { id } = await this.createDocument(
        // We'll upload documents data later on.
        { ...doc.document, data: {} },
        doc.title,
        {
          masterLanguageDocumentID,
          ...fetchParams
        }
      );
      doc.document.id = id;
    }
    reporter == null ? void 0 : reporter({
      type: "documents:created",
      data: { created }
    });
  }
  /**
   * Updates documents in the Prismic repository's migration release with their
   * patched data.
   *
   * @param migration - A migration prepared with {@link createMigration}.
   * @param params - An event listener and additional fetch parameters.
   *
   * @internal This method is one of the step performed by the {@link migrate} method.
   */
  async migrateUpdateDocuments(migration, { reporter, ...fetchParams } = {}) {
    let i = 0;
    for (const doc of migration._documents) {
      reporter == null ? void 0 : reporter({
        type: "documents:updating",
        data: {
          current: ++i,
          remaining: migration._documents.length - i,
          total: migration._documents.length,
          document: doc
        }
      });
      await this.updateDocument(
        doc.document.id,
        // We need to forward again document name and tags to update them
        // in case the document already existed during the previous step.
        {
          ...doc.document,
          data: await resolveMigrationDocumentData(doc.document.data, migration)
        },
        fetchParams
      );
    }
    reporter == null ? void 0 : reporter({
      type: "documents:updated",
      data: {
        updated: migration._documents.length
      }
    });
  }
  /**
   * Creates an asset in the Prismic media library.
   *
   * @param file - The file to upload as an asset.
   * @param filename - The filename of the asset.
   * @param params - Additional asset data and fetch parameters.
   *
   * @returns The created asset.
   */
  async createAsset(file, filename, { notes, credits, alt, tags, ...params } = {}) {
    const url = new URL("assets", this.assetAPIEndpoint);
    const formData = new FormData();
    formData.append("file", new File([file], filename, {
      type: file instanceof File ? file.type : void 0
    }));
    if (notes) {
      formData.append("notes", notes);
    }
    if (credits) {
      formData.append("credits", credits);
    }
    if (alt) {
      formData.append("alt", alt);
    }
    const asset = await this.fetch(url.toString(), this.buildAssetAPIQueryParams({
      method: "POST",
      body: formData,
      params
    }));
    if (tags && tags.length) {
      return this.updateAsset(asset.id, { tags });
    }
    return asset;
  }
  /**
   * Updates an asset in the Prismic media library.
   *
   * @param id - The ID of the asset to update.
   * @param params - The asset data to update and additional fetch parameters.
   *
   * @returns The updated asset.
   */
  async updateAsset(id, { notes, credits, alt, filename, tags, ...params } = {}) {
    const url = new URL(`assets/${id}`, this.assetAPIEndpoint);
    if (tags && tags.length) {
      tags = await this.resolveAssetTagIDs(tags, {
        createTags: true,
        ...params
      });
    }
    return this.fetch(url.toString(), this.buildAssetAPIQueryParams({
      method: "PATCH",
      body: {
        notes,
        credits,
        alt,
        filename,
        tags
      },
      params
    }));
  }
  /**
   * Fetches a foreign asset from a URL.
   *
   * @param url - The URL of the asset to fetch.
   * @param params - Additional fetch parameters.
   *
   * @returns A file representing the fetched asset.
   */
  async fetchForeignAsset(url, params = {}) {
    var _a, _b, _c, _d;
    const requestInit = {
      ...this.fetchOptions,
      ...params.fetchOptions,
      headers: {
        ...(_a = this.fetchOptions) == null ? void 0 : _a.headers,
        ...(_b = params.fetchOptions) == null ? void 0 : _b.headers
      },
      signal: ((_c = params.fetchOptions) == null ? void 0 : _c.signal) || params.signal || ((_d = this.fetchOptions) == null ? void 0 : _d.signal)
    };
    const res = await this.fetchFn(url, requestInit);
    if (!res.ok) {
      throw new PrismicError("Could not fetch foreign asset", url, void 0);
    }
    const blob = await res.blob();
    return new File([blob], "", {
      type: res.headers.get("content-type") || void 0
    });
  }
  /**
   * Resolves asset tag IDs from tag names.
   *
   * @param tagNames - An array of tag names to resolve.
   * @param params - Whether or not missing tags should be created and
   *   additional fetch parameters.
   *
   * @returns An array of resolved tag IDs.
   */
  async resolveAssetTagIDs(tagNames = [], { createTags, ...params } = {}) {
    return this._resolveAssetTagIDsLimit(async () => {
      const existingTags = await this.getAssetTags(params);
      const existingTagMap = {};
      for (const tag of existingTags) {
        existingTagMap[tag.name] = tag;
      }
      const resolvedTagIDs = [];
      for (const tagName of tagNames) {
        if (!existingTagMap[tagName] && createTags) {
          existingTagMap[tagName] = await this.createAssetTag(tagName, params);
        }
        if (existingTagMap[tagName]) {
          resolvedTagIDs.push(existingTagMap[tagName].id);
        }
      }
      return resolvedTagIDs;
    });
  }
  /**
   * Creates a tag in the Asset API.
   *
   * @remarks
   * Tags should be at least 3 characters long and 20 characters at most.
   *
   * @param name - The name of the tag to create.
   * @param params - Additional fetch parameters.
   *
   * @returns The created tag.
   */
  async createAssetTag(name, params) {
    const url = new URL("tags", this.assetAPIEndpoint);
    return this.fetch(url.toString(), this.buildAssetAPIQueryParams({
      method: "POST",
      body: { name },
      params
    }));
  }
  /**
   * Queries existing tags from the Asset API.
   *
   * @param params - Additional fetch parameters.
   *
   * @returns An array of existing tags.
   */
  async getAssetTags(params) {
    const url = new URL("tags", this.assetAPIEndpoint);
    const { items } = await this.fetch(url.toString(), this.buildAssetAPIQueryParams({ params }));
    return items;
  }
  /**
   * Creates a document in the repository's migration release.
   *
   * @typeParam TType - Type of Prismic documents to create.
   *
   * @param document - The document to create.
   * @param documentTitle - The title of the document to create which will be
   *   displayed in the editor.
   * @param params - Document master language document ID and additional fetch
   *   parameters.
   *
   * @returns The ID of the created document.
   *
   * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}
   */
  async createDocument(document, documentTitle, { masterLanguageDocumentID, ...params } = {}) {
    const url = new URL("documents", this.migrationAPIEndpoint);
    const result = await this.fetch(url.toString(), this.buildMigrationAPIQueryParams({
      method: "POST",
      body: {
        title: documentTitle,
        type: document.type,
        uid: document.uid || void 0,
        lang: document.lang,
        alternate_language_id: masterLanguageDocumentID,
        tags: document.tags,
        data: document.data
      },
      params
    }));
    return { id: result.id };
  }
  /**
   * Updates an existing document in the repository's migration release.
   *
   * @typeParam TType - Type of Prismic documents to update.
   *
   * @param id - The ID of the document to update.
   * @param document - The document content to update.
   * @param params - Additional fetch parameters.
   *
   * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}
   */
  async updateDocument(id, document, params) {
    const url = new URL(`documents/${id}`, this.migrationAPIEndpoint);
    await this.fetch(url.toString(), this.buildMigrationAPIQueryParams({
      method: "PUT",
      body: {
        title: document.documentTitle,
        uid: document.uid || void 0,
        tags: document.tags,
        data: document.data
      },
      params
    }));
  }
  /**
   * Builds fetch parameters for the Asset API.
   *
   * @typeParam TBody - Type of the body to send in the fetch request.
   *
   * @param params - Method, body, and additional fetch parameters.
   *
   * @returns An object that can be fetched to interact with the Asset API.
   *
   * @see Prismic Asset API technical reference: {@link https://prismic.io/docs/asset-api-technical-reference}
   */
  buildAssetAPIQueryParams({ method, body, params }) {
    var _a;
    const headers = {
      ...(_a = params == null ? void 0 : params.fetchOptions) == null ? void 0 : _a.headers,
      authorization: `Bearer ${this.writeToken}`,
      repository: this.repositoryName
    };
    let _body;
    if (body instanceof FormData) {
      _body = body;
    } else if (body) {
      _body = JSON.stringify(body);
      headers["content-type"] = "application/json";
    }
    return {
      ...params,
      fetchOptions: {
        ...params == null ? void 0 : params.fetchOptions,
        method,
        body: _body,
        headers
      }
    };
  }
  /**
   * Builds fetch parameters for the Migration API.
   *
   * @typeParam TBody - Type of the body to send in the fetch request.
   *
   * @param params - Method, body, and additional fetch options.
   *
   * @returns An object that can be fetched to interact with the Migration API.
   *
   * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}
   */
  buildMigrationAPIQueryParams({ method, body, params }) {
    var _a;
    return {
      ...params,
      fetchOptions: {
        ...params == null ? void 0 : params.fetchOptions,
        method,
        body: JSON.stringify(body),
        headers: {
          ...(_a = params == null ? void 0 : params.fetchOptions) == null ? void 0 : _a.headers,
          "content-type": "application/json",
          repository: this.repositoryName,
          authorization: `Bearer ${this.writeToken}`,
          "x-api-key": this.migrationAPIKey
        }
      }
    };
  }
};

// node_modules/@prismicio/client/dist/createWriteClient.js
var createWriteClient = (repositoryName, options) => new WriteClient(repositoryName, options);

// node_modules/@prismicio/client/dist/lib/validateAssetMetadata.js
var ASSET_NOTES_MAX_LENGTH = 500;
var ASSET_CREDITS_MAX_LENGTH = 500;
var ASSET_ALT_MAX_LENGTH = 500;
var ASSET_TAG_MIN_LENGTH = 3;
var ASSET_TAG_MAX_LENGTH = 20;
var validateAssetMetadata = ({ notes, credits, alt, tags }) => {
  const errors = [];
  if (notes && notes.length > ASSET_NOTES_MAX_LENGTH) {
    errors.push(`\`notes\` must be at most ${ASSET_NOTES_MAX_LENGTH} characters`);
  }
  if (credits && credits.length > ASSET_CREDITS_MAX_LENGTH) {
    errors.push(`\`credits\` must be at most ${ASSET_CREDITS_MAX_LENGTH} characters`);
  }
  if (alt && alt.length > ASSET_ALT_MAX_LENGTH) {
    errors.push(`\`alt\` must be at most ${ASSET_ALT_MAX_LENGTH} characters`);
  }
  if (tags && tags.length && tags.some((tag) => tag.length < ASSET_TAG_MIN_LENGTH || tag.length > ASSET_TAG_MAX_LENGTH)) {
    errors.push(`tags must be at least 3 characters long and 20 characters at most`);
  }
  if (errors.length) {
    throw new PrismicError(`Errors validating asset metadata: ${errors.join(", ")}`, void 0, { notes, credits, alt, tags });
  }
};

// node_modules/@prismicio/client/dist/Migration.js
var __defProp7 = Object.defineProperty;
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField7 = (obj, key, value) => __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _Migration_instances;
var migratePrismicDocumentData_fn;
var Migration = class {
  constructor() {
    __privateAdd2(this, _Migration_instances);
    __publicField7(this, "_assets", /* @__PURE__ */ new Map());
    __publicField7(this, "_documents", []);
  }
  /**
   * Registers an asset to be created in the migration from a file, an asset
   * object, or an image or link to media field.
   *
   * @remarks
   * This method does not create the asset in Prismic media library right away.
   * Instead, it registers it in your migration. The asset will be created when
   * the migration is executed through the `writeClient.migrate()` method.
   *
   * @returns A migration asset field instance.
   */
  createAsset(fileOrAssetOrField, filename, { notes, credits, alt, tags } = {}) {
    var _a;
    let config;
    let maybeInitialField;
    if (typeof fileOrAssetOrField === "object" && "url" in fileOrAssetOrField) {
      if ("dimensions" in fileOrAssetOrField || "link_type" in fileOrAssetOrField) {
        const url = fileOrAssetOrField.url.split("?")[0];
        const filename2 = "name" in fileOrAssetOrField ? fileOrAssetOrField.name : url.split("/").pop().split("_").pop();
        const credits2 = "copyright" in fileOrAssetOrField && fileOrAssetOrField.copyright ? fileOrAssetOrField.copyright : void 0;
        const alt2 = "alt" in fileOrAssetOrField && fileOrAssetOrField.alt ? fileOrAssetOrField.alt : void 0;
        if ("dimensions" in fileOrAssetOrField) {
          maybeInitialField = fileOrAssetOrField;
        }
        config = {
          id: fileOrAssetOrField.id,
          file: url,
          filename: filename2,
          notes: void 0,
          credits: credits2,
          alt: alt2,
          tags: void 0
        };
      } else {
        config = {
          id: fileOrAssetOrField.id,
          file: fileOrAssetOrField.url,
          filename: fileOrAssetOrField.filename,
          notes: fileOrAssetOrField.notes,
          credits: fileOrAssetOrField.credits,
          alt: fileOrAssetOrField.alt,
          tags: (_a = fileOrAssetOrField.tags) == null ? void 0 : _a.map(({ name }) => name)
        };
      }
    } else {
      config = {
        id: fileOrAssetOrField,
        file: fileOrAssetOrField,
        filename,
        notes,
        credits,
        alt,
        tags
      };
    }
    validateAssetMetadata(config);
    const migrationAsset = new PrismicMigrationAsset(config, maybeInitialField);
    const maybeAsset = this._assets.get(config.id);
    if (maybeAsset) {
      maybeAsset.config.notes = maybeAsset.config.notes || config.notes;
      maybeAsset.config.credits = maybeAsset.config.credits || config.credits;
      maybeAsset.config.alt = maybeAsset.config.alt || config.alt;
      maybeAsset.config.tags = Array.from(/* @__PURE__ */ new Set([...maybeAsset.config.tags || [], ...config.tags || []]));
    } else {
      this._assets.set(config.id, migrationAsset);
    }
    return migrationAsset;
  }
  /**
   * Registers a document to be created in the migration.
   *
   * @remarks
   * This method does not create the document in Prismic right away. Instead, it
   * registers it in your migration. The document will be created when the
   * migration is executed through the `writeClient.migrate()` method.
   *
   * @typeParam TType - Type of the Prismic document to create.
   *
   * @param document - The document to create.
   * @param title - The title of the document to create which will be displayed
   *   in the editor.
   * @param params - Document master language document ID.
   *
   * @returns A migration document instance.
   */
  createDocument(document, title2, params) {
    const doc = new PrismicMigrationDocument(document, title2, params);
    this._documents.push(doc);
    return doc;
  }
  /**
   * Registers an existing document to be updated in the migration.
   *
   * @remarks
   * This method does not update the document in Prismic right away. Instead, it
   * registers it in your migration. The document will be updated when the
   * migration is executed through the `writeClient.migrate()` method.
   *
   * @typeParam TType - Type of Prismic documents to update.
   *
   * @param document - The document to update.
   * @param title - The title of the document to update which will be displayed
   *   in the editor.
   *
   * @returns A migration document instance.
   */
  updateDocument(document, title2) {
    const doc = new PrismicMigrationDocument(document, title2);
    this._documents.push(doc);
    return doc;
  }
  /**
   * Registers a document from another Prismic repository to be created in the
   * migration.
   *
   * @remarks
   * This method does not create the document in Prismic right away. Instead, it
   * registers it in your migration. The document will be created when the
   * migration is executed through the `writeClient.migrate()` method.
   *
   * @param document - The document from Prismic to create.
   * @param title - The title of the document to create which will be displayed
   *   in the editor.
   *
   * @returns A migration document instance.
   */
  createDocumentFromPrismic(document, title2) {
    const doc = new PrismicMigrationDocument(__privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, {
      type: document.type,
      lang: document.lang,
      uid: document.uid,
      tags: document.tags,
      data: document.data
    }), title2, { originalPrismicDocument: document });
    this._documents.push(doc);
    return doc;
  }
  /**
   * Queries a document from the migration instance with a specific UID and
   * custom type.
   *
   * @example
   *
   * ```ts
   * const contentRelationship = migration.createContentRelationship(() =>
   * 	migration.getByUID("blog_post", "my-first-post"),
   * )
   * ```
   *
   * @typeParam TType - Type of the Prismic document returned.
   *
   * @param type - The API ID of the document's custom type.
   * @param uid - The UID of the document.
   *
   * @returns The migration document instance with a UID matching the `uid`
   *   parameter, if a matching document is found.
   */
  getByUID(type, uid) {
    return this._documents.find((doc) => doc.document.type === type && doc.document.uid === uid);
  }
  /**
   * Queries a singleton document from the migration instance for a specific
   * custom type.
   *
   * @example
   *
   * ```ts
   * const contentRelationship = migration.createContentRelationship(() =>
   * 	migration.getSingle("settings"),
   * )
   * ```
   *
   * @typeParam TType - Type of the Prismic document returned.
   *
   * @param type - The API ID of the singleton custom type.
   *
   * @returns The migration document instance for the custom type, if a matching
   *   document is found.
   */
  getSingle(type) {
    return this._documents.find((doc) => doc.document.type === type);
  }
  /**
   * Queries a document from the migration instance for a specific original ID.
   *
   * @example
   *
   * ```ts
   * const contentRelationship = migration.createContentRelationship(() =>
   * 	migration._getByOriginalID("YhdrDxIAACgAcp_b"),
   * )
   * ```
   *
   * @typeParam TType - Type of the Prismic document returned.
   *
   * @param id - The original ID of the Prismic document.
   *
   * @returns The migration document instance for the original ID, if a matching
   *   document is found.
   *
   * @internal
   */
  _getByOriginalID(id) {
    return this._documents.find((doc) => {
      var _a;
      return ((_a = doc.originalPrismicDocument) == null ? void 0 : _a.id) === id;
    });
  }
};
_Migration_instances = /* @__PURE__ */ new WeakSet();
migratePrismicDocumentData_fn = function(input) {
  if (filledContentRelationship(input)) {
    if (input.isBroken) {
      return {
        link_type: LinkType.Document,
        // ID needs to be 16 characters long to be considered valid by the API
        id: "_____broken_____",
        isBroken: true,
        text: input.text
      };
    }
    return {
      link_type: LinkType.Document,
      id: () => this._getByOriginalID(input.id),
      text: input.text
    };
  }
  if (filledLinkToMedia(input)) {
    return {
      link_type: LinkType.Media,
      id: this.createAsset(input),
      text: input.text
    };
  }
  if (rtImageNode(input)) {
    const rtImageNode22 = {
      type: RichTextNodeType.image,
      id: this.createAsset(input)
    };
    if (input.linkTo) {
      rtImageNode22.linkTo = __privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, input.linkTo);
    }
    return rtImageNode22;
  }
  if (filledImage(input)) {
    const image3 = {
      id: this.createAsset(input)
    };
    const { id: _id, url: _url, dimensions: _dimensions, edit: _edit, alt: _alt, copyright: _copyright, ...thumbnails } = input;
    for (const name in thumbnails) {
      if (filledImage(thumbnails[name])) {
        image3[name] = this.createAsset(thumbnails[name]);
      }
    }
    return image3;
  }
  if (Array.isArray(input)) {
    return input.map((element) => __privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, element));
  }
  if (input && typeof input === "object") {
    const res = {};
    for (const key in input) {
      res[key] = __privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, input[key]);
    }
    return res;
  }
  return input;
};

// node_modules/@prismicio/client/dist/createMigration.js
var createMigration = () => new Migration();

// node_modules/@prismicio/client/dist/getGraphQLEndpoint.js
var getGraphQLEndpoint = (repositoryName) => {
  if (isRepositoryName(repositoryName)) {
    return `https://${repositoryName}.cdn.prismic.io/graphql`;
  } else {
    throw new PrismicError(`An invalid Prismic repository name was given: ${repositoryName}`, void 0, void 0);
  }
};

// node_modules/@prismicio/client/dist/getToolbarSrc.js
var getToolbarSrc = (repositoryName) => {
  if (isRepositoryName(repositoryName)) {
    return `https://static.cdn.prismic.io/prismic.js?new=true&repo=${repositoryName}`;
  } else {
    throw new PrismicError(`An invalid Prismic repository name was given: ${repositoryName}`, void 0, void 0);
  }
};

// node_modules/@prismicio/client/dist/helpers/asDate.js
var asDate = (dateOrTimestampField) => {
  if (!dateOrTimestampField) {
    return null;
  }
  if (dateOrTimestampField.length === 24) {
    return new Date(dateOrTimestampField.replace(/(\+|-)(\d{2})(\d{2})$/, ".000$1$2:$3"));
  } else {
    return new Date(dateOrTimestampField);
  }
};

// node_modules/@prismicio/client/dist/lib/isInternalURL.js
var isInternalURL = (url) => {
  const isInternal = /^(\/(?!\/)|#)/.test(url);
  const isSpecialLink = !isInternal && !/^https?:\/\//.test(url);
  return isInternal && !isSpecialLink;
};

// node_modules/@prismicio/client/dist/helpers/asLinkAttrs.js
var asLinkAttrs = (linkFieldOrDocument, config = {}) => {
  if (linkFieldOrDocument && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501
  ("link_type" in linkFieldOrDocument ? link(linkFieldOrDocument) : linkFieldOrDocument)) {
    const target = (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501
      "target" in linkFieldOrDocument ? linkFieldOrDocument.target : void 0
    );
    const rawHref = asLink(linkFieldOrDocument, config.linkResolver);
    const href = rawHref == null ? void 0 : rawHref;
    const isExternal = typeof href === "string" ? !isInternalURL(href) : false;
    const rel = config.rel ? config.rel({ href, isExternal, target }) : isExternal ? "noreferrer" : void 0;
    return {
      href,
      target,
      rel: rel == null ? void 0 : rel
    };
  }
  return {};
};

// node_modules/@prismicio/client/dist/richtext/asText.js
var asText = (richTextField, separator = " ") => {
  let result = "";
  for (let i = 0; i < richTextField.length; i++) {
    if ("text" in richTextField[i]) {
      result += (result ? separator : "") + richTextField[i].text;
    }
  }
  return result;
};

// node_modules/@prismicio/client/dist/helpers/asText.js
var asText2 = (richTextField, ...configObjectOrTuple) => {
  if (richTextField) {
    const [configObjectOrSeparator] = configObjectOrTuple;
    let config;
    if (typeof configObjectOrSeparator === "string") {
      config = {
        separator: configObjectOrSeparator
      };
    } else {
      config = { ...configObjectOrSeparator };
    }
    return asText(richTextField, config.separator);
  } else {
    return null;
  }
};

// node_modules/@prismicio/client/dist/lib/escapeHTML.js
var matchHtmlRegExp = /["'&<>]/;
var escapeHTML = (string) => {
  const str = "" + string;
  const match = matchHtmlRegExp.exec(str);
  if (!match) {
    return str;
  }
  let escape;
  let html = "";
  let index = 0;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escape;
  }
  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
};

// node_modules/@prismicio/client/dist/lib/serializerHelpers.js
var formatAttributes = (node, attributes) => {
  const _attributes = { ...attributes };
  if ("direction" in node && node.direction === "rtl") {
    _attributes.dir = node.direction;
  }
  if ("data" in node && "label" in node.data && node.data.label) {
    _attributes.class = _attributes.class ? `${_attributes.class} ${node.data.label}` : node.data.label;
  }
  const result = [];
  for (const key in _attributes) {
    const value = _attributes[key];
    if (value) {
      if (typeof value === "boolean") {
        result.push(key);
      } else {
        result.push(`${key}="${escapeHTML(value)}"`);
      }
    }
  }
  if (result.length) {
    result.unshift("");
  }
  return result.join(" ");
};
var getGeneralAttributes = (serializerOrShorthand) => {
  return serializerOrShorthand && typeof serializerOrShorthand !== "function" ? serializerOrShorthand : {};
};
var serializeStandardTag = (tag, serializerOrShorthand) => {
  const generalAttributes = getGeneralAttributes(serializerOrShorthand);
  return ({ node, children }) => {
    return `<${tag}${formatAttributes(node, generalAttributes)}>${children}</${tag}>`;
  };
};
var serializePreFormatted = (serializerOrShorthand) => {
  const generalAttributes = getGeneralAttributes(serializerOrShorthand);
  return ({ node }) => {
    return `<pre${formatAttributes(node, generalAttributes)}>${escapeHTML(node.text)}</pre>`;
  };
};
var serializeImage = (linkResolver, serializerOrShorthand) => {
  const generalAttributes = getGeneralAttributes(serializerOrShorthand);
  return ({ node }) => {
    const attributes = {
      ...generalAttributes,
      src: node.url,
      alt: node.alt,
      copyright: node.copyright
    };
    let imageTag = `<img${formatAttributes(node, attributes)} />`;
    if (node.linkTo) {
      imageTag = serializeHyperlink(linkResolver)({
        type: "hyperlink",
        node: {
          type: "hyperlink",
          data: node.linkTo,
          start: 0,
          end: 0
        },
        text: "",
        children: imageTag,
        key: ""
      });
    }
    return `<p class="block-img">${imageTag}</p>`;
  };
};
var serializeEmbed = (serializerOrShorthand) => {
  const generalAttributes = getGeneralAttributes(serializerOrShorthand);
  return ({ node }) => {
    const attributes = {
      ...generalAttributes,
      ["data-oembed"]: node.oembed.embed_url,
      ["data-oembed-type"]: node.oembed.type,
      ["data-oembed-provider"]: node.oembed.provider_name
    };
    return `<div${formatAttributes(node, attributes)}>${node.oembed.html}</div>`;
  };
};
var serializeHyperlink = (linkResolver, serializerOrShorthand) => {
  const generalAttributes = getGeneralAttributes(serializerOrShorthand);
  return ({ node, children }) => {
    const attributes = {
      ...generalAttributes
    };
    if (node.data.link_type === LinkType.Web) {
      attributes.href = node.data.url;
      attributes.target = node.data.target;
      attributes.rel = "noopener noreferrer";
    } else if (node.data.link_type === LinkType.Document) {
      attributes.href = asLink(node.data, { linkResolver });
    } else if (node.data.link_type === LinkType.Media) {
      attributes.href = node.data.url;
    }
    return `<a${formatAttributes(node, attributes)}>${children}</a>`;
  };
};
var serializeSpan = () => {
  return ({ text }) => {
    return text ? escapeHTML(text).replace(/\n/g, "<br />") : "";
  };
};

// node_modules/@prismicio/client/dist/richtext/asTree.js
var uuid = () => {
  return (++uuid.i).toString();
};
uuid.i = 0;
var asTree = (nodes) => {
  const preparedNodes = prepareNodes(nodes);
  const children = [];
  for (let i = 0; i < preparedNodes.length; i++) {
    children.push(nodeToTreeNode(preparedNodes[i]));
  }
  return {
    key: uuid(),
    children
  };
};
var createTreeNode = (node, children = []) => {
  return {
    key: uuid(),
    type: node.type,
    text: "text" in node ? node.text : void 0,
    node,
    children
  };
};
var createTextTreeNode = (text) => {
  return createTreeNode({
    type: RichTextNodeType.span,
    text,
    spans: []
  });
};
var prepareNodes = (nodes) => {
  const mutNodes = nodes.slice(0);
  for (let i = 0; i < mutNodes.length; i++) {
    const node = mutNodes[i];
    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {
      const items = [
        node
      ];
      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {
        items.push(mutNodes[i + 1]);
        mutNodes.splice(i, 1);
      }
      if (node.type === RichTextNodeType.listItem) {
        mutNodes[i] = {
          type: RichTextNodeType.list,
          items
        };
      } else {
        mutNodes[i] = {
          type: RichTextNodeType.oList,
          items
        };
      }
    }
  }
  return mutNodes;
};
var nodeToTreeNode = (node) => {
  if ("text" in node) {
    return createTreeNode(node, textNodeSpansToTreeNodeChildren(node.spans, node));
  }
  if ("items" in node) {
    const children = [];
    for (let i = 0; i < node.items.length; i++) {
      children.push(nodeToTreeNode(node.items[i]));
    }
    return createTreeNode(node, children);
  }
  return createTreeNode(node);
};
var textNodeSpansToTreeNodeChildren = (spans, node, parentSpan) => {
  if (!spans.length) {
    return [createTextTreeNode(node.text)];
  }
  const mutSpans = spans.slice(0);
  mutSpans.sort((a, b) => a.start - b.start || b.end - a.end);
  const children = [];
  for (let i = 0; i < mutSpans.length; i++) {
    const span = mutSpans[i];
    const parentSpanStart = parentSpan && parentSpan.start || 0;
    const spanStart = span.start - parentSpanStart;
    const spanEnd = span.end - parentSpanStart;
    const text = node.text.slice(spanStart, spanEnd);
    const childSpans = [];
    for (let j = i; j < mutSpans.length; j++) {
      const siblingSpan = mutSpans[j];
      if (siblingSpan !== span) {
        if (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {
          childSpans.push(siblingSpan);
          mutSpans.splice(j, 1);
          j--;
        } else if (siblingSpan.start < span.end && siblingSpan.end > span.start) {
          childSpans.push({
            ...siblingSpan,
            end: span.end
          });
          mutSpans[j] = {
            ...siblingSpan,
            start: span.end
          };
        }
      }
    }
    if (i === 0 && spanStart > 0) {
      children.push(createTextTreeNode(node.text.slice(0, spanStart)));
    }
    const spanWithText = { ...span, text };
    children.push(createTreeNode(spanWithText, textNodeSpansToTreeNodeChildren(childSpans, {
      ...node,
      text
    }, span)));
    if (spanEnd < node.text.length) {
      children.push(createTextTreeNode(node.text.slice(spanEnd, mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0)));
    }
  }
  return children;
};

// node_modules/@prismicio/client/dist/richtext/serialize.js
var serialize = (richTextField, serializer) => {
  return serializeTreeNodes(asTree(richTextField).children, serializer);
};
var serializeTreeNodes = (nodes, serializer) => {
  const serializedTreeNodes = [];
  for (let i = 0; i < nodes.length; i++) {
    const treeNode = nodes[i];
    const serializedTreeNode = serializer(treeNode.type, treeNode.node, treeNode.text, serializeTreeNodes(treeNode.children, serializer), treeNode.key);
    if (serializedTreeNode != null) {
      serializedTreeNodes.push(serializedTreeNode);
    }
  }
  return serializedTreeNodes;
};

// node_modules/@prismicio/client/dist/richtext/types.js
var RichTextReversedNodeType = {
  [RichTextNodeType.listItem]: "listItem",
  [RichTextNodeType.oListItem]: "oListItem",
  [RichTextNodeType.list]: "list",
  [RichTextNodeType.oList]: "oList"
};

// node_modules/@prismicio/client/dist/richtext/wrapMapSerializer.js
var wrapMapSerializer = (mapSerializer) => {
  return (type, node, text, children, key) => {
    const tagSerializer = mapSerializer[RichTextReversedNodeType[type] || type];
    if (tagSerializer) {
      return tagSerializer({
        // @ts-expect-error cannot type check here
        type,
        // @ts-expect-error cannot type check here
        node,
        // @ts-expect-error cannot type check here
        text,
        // @ts-expect-error cannot type check here
        children,
        // @ts-expect-error cannot type check here
        key
      });
    }
  };
};

// node_modules/@prismicio/client/dist/richtext/composeSerializers.js
var composeSerializers = (...serializers) => {
  return (...args) => {
    for (let i = 0; i < serializers.length; i++) {
      const serializer = serializers[i];
      if (serializer) {
        const res = serializer(...args);
        if (res != null) {
          return res;
        }
      }
    }
  };
};

// node_modules/@prismicio/client/dist/helpers/asHTML.js
var createHTMLRichTextSerializer = (linkResolver, serializer) => {
  const useSerializerOrDefault = (nodeSerializerOrShorthand, defaultWithShorthand) => {
    if (typeof nodeSerializerOrShorthand === "function") {
      return (payload) => {
        return (nodeSerializerOrShorthand == null ? void 0 : nodeSerializerOrShorthand(payload)) || defaultWithShorthand(payload);
      };
    }
    return defaultWithShorthand;
  };
  const mapSerializer = {
    heading1: useSerializerOrDefault(serializer == null ? void 0 : serializer.heading1, serializeStandardTag("h1", serializer == null ? void 0 : serializer.heading1)),
    heading2: useSerializerOrDefault(serializer == null ? void 0 : serializer.heading2, serializeStandardTag("h2", serializer == null ? void 0 : serializer.heading2)),
    heading3: useSerializerOrDefault(serializer == null ? void 0 : serializer.heading3, serializeStandardTag("h3", serializer == null ? void 0 : serializer.heading3)),
    heading4: useSerializerOrDefault(serializer == null ? void 0 : serializer.heading4, serializeStandardTag("h4", serializer == null ? void 0 : serializer.heading4)),
    heading5: useSerializerOrDefault(serializer == null ? void 0 : serializer.heading5, serializeStandardTag("h5", serializer == null ? void 0 : serializer.heading5)),
    heading6: useSerializerOrDefault(serializer == null ? void 0 : serializer.heading6, serializeStandardTag("h6", serializer == null ? void 0 : serializer.heading6)),
    paragraph: useSerializerOrDefault(serializer == null ? void 0 : serializer.paragraph, serializeStandardTag("p", serializer == null ? void 0 : serializer.paragraph)),
    preformatted: useSerializerOrDefault(serializer == null ? void 0 : serializer.preformatted, serializePreFormatted(serializer == null ? void 0 : serializer.preformatted)),
    strong: useSerializerOrDefault(serializer == null ? void 0 : serializer.strong, serializeStandardTag("strong", serializer == null ? void 0 : serializer.strong)),
    em: useSerializerOrDefault(serializer == null ? void 0 : serializer.em, serializeStandardTag("em", serializer == null ? void 0 : serializer.em)),
    listItem: useSerializerOrDefault(serializer == null ? void 0 : serializer.listItem, serializeStandardTag("li", serializer == null ? void 0 : serializer.listItem)),
    oListItem: useSerializerOrDefault(serializer == null ? void 0 : serializer.oListItem, serializeStandardTag("li", serializer == null ? void 0 : serializer.oListItem)),
    list: useSerializerOrDefault(serializer == null ? void 0 : serializer.list, serializeStandardTag("ul", serializer == null ? void 0 : serializer.list)),
    oList: useSerializerOrDefault(serializer == null ? void 0 : serializer.oList, serializeStandardTag("ol", serializer == null ? void 0 : serializer.oList)),
    image: useSerializerOrDefault(serializer == null ? void 0 : serializer.image, serializeImage(linkResolver, serializer == null ? void 0 : serializer.image)),
    embed: useSerializerOrDefault(serializer == null ? void 0 : serializer.embed, serializeEmbed(serializer == null ? void 0 : serializer.embed)),
    hyperlink: useSerializerOrDefault(serializer == null ? void 0 : serializer.hyperlink, serializeHyperlink(linkResolver, serializer == null ? void 0 : serializer.hyperlink)),
    label: useSerializerOrDefault(serializer == null ? void 0 : serializer.label, serializeStandardTag("span", serializer == null ? void 0 : serializer.label)),
    span: useSerializerOrDefault(serializer == null ? void 0 : serializer.span, serializeSpan())
  };
  return wrapMapSerializerWithStringChildren(mapSerializer);
};
var wrapMapSerializerWithStringChildren = (mapSerializer) => {
  const modifiedMapSerializer = {};
  for (const tag in mapSerializer) {
    const tagSerializer = mapSerializer[tag];
    if (tagSerializer) {
      modifiedMapSerializer[tag] = (payload) => {
        return tagSerializer({
          ...payload,
          // @ts-expect-error - merging blockSerializer types causes TS to bail to a never type
          children: payload.children.join("")
        });
      };
    }
  }
  return wrapMapSerializer(modifiedMapSerializer);
};
var asHTML = (richTextField, ...configObjectOrTuple) => {
  if (richTextField) {
    const [configObjectOrLinkResolver, maybeSerializer] = configObjectOrTuple;
    let config;
    if (typeof configObjectOrLinkResolver === "function" || configObjectOrLinkResolver == null) {
      config = {
        linkResolver: configObjectOrLinkResolver,
        serializer: maybeSerializer
      };
    } else {
      config = { ...configObjectOrLinkResolver };
    }
    let serializer;
    if (config.serializer) {
      if (typeof config.serializer === "function") {
        serializer = composeSerializers((type, node, text, children, key) => (
          // TypeScript doesn't narrow the type correctly here since it is now in a callback function, so we have to cast it here.
          config.serializer(type, node, text, children.join(""), key)
        ), createHTMLRichTextSerializer(config.linkResolver));
      } else {
        serializer = createHTMLRichTextSerializer(config.linkResolver, config.serializer);
      }
    } else {
      serializer = createHTMLRichTextSerializer(config.linkResolver);
    }
    return serialize(richTextField, serializer).join("");
  } else {
    return null;
  }
};

// node_modules/imgix-url-builder/dist/buildURL.js
var camelCaseToParamCase = (input) => {
  return input.replace(/[A-Z]/g, (match) => {
    return `-${match.toLowerCase()}`;
  });
};
var buildURL = (url, params) => {
  const instance = new URL(url);
  for (const camelCasedParamKey in params) {
    const paramKey = camelCaseToParamCase(camelCasedParamKey);
    const paramValue = params[camelCasedParamKey];
    if (paramValue === void 0) {
      instance.searchParams.delete(paramKey);
    } else if (Array.isArray(paramValue)) {
      instance.searchParams.set(paramKey, paramValue.join(","));
    } else {
      instance.searchParams.set(paramKey, `${paramValue}`);
    }
  }
  const s = instance.searchParams.get("s");
  if (s) {
    instance.searchParams.delete("s");
    instance.searchParams.append("s", s);
  }
  return instance.toString();
};

// node_modules/imgix-url-builder/dist/buildPixelDensitySrcSet.js
var buildPixelDensitySrcSet = (url, { pixelDensities, ...params }) => {
  return pixelDensities.map((dpr) => {
    return `${buildURL(url, { ...params, dpr })} ${dpr}x`;
  }).join(", ");
};

// node_modules/imgix-url-builder/dist/buildWidthSrcSet.js
var buildWidthSrcSet = (url, { widths, ...params }) => {
  return widths.map((width) => {
    return `${buildURL(url, { ...params, w: void 0, width })} ${width}w`;
  }).join(", ");
};

// node_modules/@prismicio/client/dist/helpers/asImageSrc.js
var asImageSrc = (field, config = {}) => {
  if (field && imageThumbnail(field)) {
    return buildURL(field.url, config);
  } else {
    return null;
  }
};

// node_modules/@prismicio/client/dist/helpers/asImageWidthSrcSet.js
var DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840];
var asImageWidthSrcSet = (field, config = {}) => {
  if (field && imageThumbnail(field)) {
    let {
      widths = DEFAULT_WIDTHS,
      // eslint-disable-next-line prefer-const
      ...imgixParams
    } = config;
    const { url, dimensions, id: _id, alt: _alt, copyright: _copyright, edit: _edit, ...responsiveViews } = field;
    const responsiveViewObjects = Object.values(responsiveViews);
    if (widths === "thumbnails" && responsiveViewObjects.length < 1) {
      widths = DEFAULT_WIDTHS;
    }
    return {
      src: buildURL(url, imgixParams),
      srcset: (
        // By this point, we know `widths` can only be
        // `"thubmanils"` if the field has thumbnails.
        widths === "thumbnails" ? [
          buildWidthSrcSet(url, {
            ...imgixParams,
            widths: [dimensions.width]
          }),
          ...responsiveViewObjects.map((thumbnail) => {
            return buildWidthSrcSet(thumbnail.url, {
              ...imgixParams,
              widths: [thumbnail.dimensions.width]
            });
          })
        ].join(", ") : buildWidthSrcSet(field.url, {
          ...imgixParams,
          widths
        })
      )
    };
  } else {
    return null;
  }
};

// node_modules/@prismicio/client/dist/helpers/asImagePixelDensitySrcSet.js
var DEFAULT_PIXEL_DENSITIES = [1, 2, 3];
var asImagePixelDensitySrcSet = (field, config = {}) => {
  if (field && imageThumbnail(field)) {
    const { pixelDensities = DEFAULT_PIXEL_DENSITIES, ...imgixParams } = config;
    return {
      src: buildURL(field.url, imgixParams),
      srcset: buildPixelDensitySrcSet(field.url, {
        ...imgixParams,
        pixelDensities
      })
    };
  } else {
    return null;
  }
};

// node_modules/@prismicio/client/dist/types/value/embed.js
var OEmbedType = {
  Photo: "photo",
  Video: "video",
  Link: "link",
  Rich: "rich"
};

// node_modules/@prismicio/client/dist/types/model/types.js
var CustomTypeModelFieldType = {
  Boolean: "Boolean",
  Color: "Color",
  Date: "Date",
  Embed: "Embed",
  GeoPoint: "GeoPoint",
  Group: "Group",
  Image: "Image",
  Integration: "IntegrationFields",
  Link: "Link",
  Number: "Number",
  Select: "Select",
  Slices: "Slices",
  StructuredText: "StructuredText",
  Text: "Text",
  Timestamp: "Timestamp",
  UID: "UID",
  /**
   * @deprecated - Renamed to `Integration`.
   */
  IntegrationFields: "IntegrationFields",
  /**
   * @deprecated - Legacy field type. Use `Number` instead.
   */
  Range: "Range",
  /**
   * @deprecated - Legacy field type. Do not use.
   */
  Separator: "Separator",
  /**
   * @deprecated - Legacy field type. Use `Slices` instead.
   */
  LegacySlices: "Choice"
};

// node_modules/@prismicio/client/dist/types/model/link.js
var CustomTypeModelLinkSelectType = {
  Document: "document",
  Media: "media",
  Web: "web"
};

// node_modules/@prismicio/client/dist/types/model/sliceZone.js
var CustomTypeModelSliceType = {
  Slice: "Slice",
  SharedSlice: "SharedSlice"
};

// node_modules/@prismicio/client/dist/types/model/slice.js
var CustomTypeModelSliceDisplay = {
  List: "list",
  Grid: "grid"
};

// node_modules/@prismicio/client/dist/types/webhook/types.js
var WebhookType = {
  APIUpdate: "api-update",
  TestTrigger: "test-trigger"
};

// node_modules/@prismicio/client/dist/index.js
var predicate = filter;
var unstable_mapSliceZone = mapSliceZone;
var Element = RichTextNodeType;

export {
  RichTextNodeType,
  mapSliceZone,
  filter,
  PrismicError,
  cookie_exports,
  ForbiddenError,
  NotFoundError,
  ParsingError,
  PreviewTokenExpiredError,
  RefExpiredError,
  RefNotFoundError,
  RepositoryNotFoundError,
  LinkType,
  documentToLinkField,
  asLink,
  buildQueryURL,
  isRepositoryName,
  getRepositoryEndpoint,
  getRepositoryName,
  isRepositoryEndpoint,
  Client,
  createClient,
  PrismicMigrationAsset,
  PrismicMigrationDocument,
  isFilled_exports,
  WriteClient,
  createWriteClient,
  Migration,
  createMigration,
  getGraphQLEndpoint,
  getToolbarSrc,
  asDate,
  asLinkAttrs,
  asText2 as asText,
  asHTML,
  asImageSrc,
  asImageWidthSrcSet,
  asImagePixelDensitySrcSet,
  OEmbedType,
  CustomTypeModelFieldType,
  CustomTypeModelLinkSelectType,
  CustomTypeModelSliceType,
  CustomTypeModelSliceDisplay,
  WebhookType,
  predicate,
  unstable_mapSliceZone,
  Element
};
//# sourceMappingURL=chunk-WLSFXDXB.js.map
