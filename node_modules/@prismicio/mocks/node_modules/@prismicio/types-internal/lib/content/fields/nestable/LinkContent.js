"use strict";
/**
 * LinkContent is a union of different link content types.
 *
 * Most link content types are built from a union of a filled and an unfilled version.
 *
 * Filled versions make sure that the important fields that make the link work
 * are present. They are also exported for when there's a need to ensure that
 * the link is filled when used in a specific context, e.g. links in rich text fields.
 *
 * Unfilled versions are used when the link is not filled yet but contains other
 * information like the text.
 *
 * There are some exceptions that don't have a filled version (e.g. MediaLink)
 * for when the exact subtype is not yet known.
 *
 * Unfilled versions all have a special `kind` property that is used to
 * determine the type of the link. For legacy reasons, filled versions don't
 * necessarily require this property or its type is loose (e.g. `string`). In
 * this cases, the type is determined based on a specific combination of the
 * rest of the link data. This is why the order of the subtypes in the union is
 * important and should be from the most specific to the least specific. A
 * battery of tests ensures that the correct type is inferred.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilledLinkContent = exports.FilledLink = exports.FilledLinkContentLegacy = exports.FilledLinkLegacy = exports.isFilledLinkContent = exports.LinkContent = exports.Link = exports.LinkContentLegacy = exports.LinkLegacy = exports.isLinkContent = exports.LinkContentType = exports.AnyLinkContent = exports.AnyLinkType = exports.ExternalLinkContent = exports.FilledExternalLinkContent = exports.ExternalLinkType = exports.DocumentLinkContent = exports.FilledDocumentLinkContent = exports.DocumentLinkType = exports.MediaLinkContent = exports.MediaLinkType = exports.FileLinkContent = exports.FilledFileLinkContent = exports.FileLinkType = exports.ImageLinkContent = exports.FilledImageLinkContent = exports.ImageLinkType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const uuid_1 = require("uuid");
const validators_1 = require("../../../validators");
const function_2 = require("../../../validators/function");
const utils_1 = require("../../utils");
const isUuid = (input) => typeof input === "string" && (0, uuid_1.validate)(input);
const uuidWithFallback = new t.Type("UUID", isUuid, (u, c) => {
    if (typeof u === "undefined")
        return t.success((0, uuid_1.v4)());
    if (isUuid(u))
        return t.success(u);
    return t.failure(u, c);
}, t.identity);
function withKey(codec) {
    return t.intersection([t.strict({ key: uuidWithFallback }), codec]);
}
// ImageLink.
exports.ImageLinkType = "ImageLink";
const isImageLinkKind = (input) => typeof input === "string";
const ImageLinkKind = new t.Type("ImageLinkKind", (input) => isImageLinkKind(input), (input, context) => isImageLinkKind(input)
    ? t.success("image")
    : t.failure(input, context), () => "image");
const filledImageLinkLegacyCodec = t.intersection([
    t.strict({
        kind: ImageLinkKind,
        id: t.string,
        url: t.string,
        height: t.string,
        width: t.string,
        size: t.string,
        name: t.string,
    }),
    t.exact(t.partial({
        date: validators_1.StringOrNull,
    })),
]);
const FilledImageLinkLegacy = new t.Type("FilledImageLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.ImageLinkType, (image) => {
    return (0, function_1.pipe)(filledImageLinkLegacyCodec.decode(image), fp_ts_1.either.map((parsedImage) => {
        return exports.FilledImageLinkContent.encode({
            ...parsedImage,
            __TYPE__: exports.ImageLinkType,
        });
    }));
}, (image) => {
    return filledImageLinkLegacyCodec.encode(image);
});
exports.FilledImageLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.ImageLinkType),
    }),
    filledImageLinkLegacyCodec,
]);
const imageLinkLegacyCodec = t.intersection([
    t.union([
        filledImageLinkLegacyCodec,
        t.strict({
            kind: t.literal("image"),
        }),
    ]),
    t.exact(t.partial({
        text: t.string,
    })),
]);
const ImageLinkLegacy = new t.Type("ImageLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.ImageLinkType, (image) => {
    return (0, function_1.pipe)(imageLinkLegacyCodec.decode(image), fp_ts_1.either.map((parsedImage) => {
        return exports.ImageLinkContent.encode({
            ...parsedImage,
            __TYPE__: exports.ImageLinkType,
        });
    }));
}, (image) => {
    return imageLinkLegacyCodec.encode(image);
});
exports.ImageLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.ImageLinkType),
    }),
    imageLinkLegacyCodec,
]);
// FileLink.
exports.FileLinkType = "FileLink";
const isFileLinkKind = (input) => typeof input === "string";
const FileLinkKind = new t.Type("FileLinkKind", (input) => isFileLinkKind(input), (input, context) => isFileLinkKind(input)
    ? t.success("file")
    : t.failure(input, context), () => "file");
const filledFileLinkLegacyCodec = t.exact(t.intersection([
    t.type({
        kind: FileLinkKind,
        id: t.string,
        url: t.string,
        name: t.string,
        size: (0, io_ts_types_1.withFallback)(t.string, "0"),
    }),
    t.partial({ date: validators_1.StringOrNull }),
]));
const FilledFileLinkLegacy = new t.Type("FilledFileLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.FileLinkType, (file) => {
    return (0, function_1.pipe)(filledFileLinkLegacyCodec.decode(file), fp_ts_1.either.map((parsedFile) => {
        return exports.FilledFileLinkContent.encode({
            ...parsedFile,
            __TYPE__: exports.FileLinkType,
        });
    }));
}, (file) => {
    return filledFileLinkLegacyCodec.encode(file);
});
exports.FilledFileLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.FileLinkType),
    }),
    filledFileLinkLegacyCodec,
]);
const fileLinkLegacyCodec = t.intersection([
    t.union([
        filledFileLinkLegacyCodec,
        t.strict({
            kind: t.literal("file"),
        }),
    ]),
    t.exact(t.partial({
        text: t.string,
    })),
]);
const FileLinkLegacy = new t.Type("FileLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.FileLinkType, (file) => {
    return (0, function_1.pipe)(fileLinkLegacyCodec.decode(file), fp_ts_1.either.map((parsedFile) => {
        return exports.FileLinkContent.encode({
            ...parsedFile,
            __TYPE__: exports.FileLinkType,
        });
    }));
}, (file) => {
    return fileLinkLegacyCodec.encode(file);
});
exports.FileLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.FileLinkType),
    }),
    fileLinkLegacyCodec,
]);
// MediaLink.
exports.MediaLinkType = "MediaLink";
const mediaLinkLegacyCodec = t.intersection([
    t.strict({
        kind: t.literal("media"),
    }),
    t.exact(t.partial({
        text: t.string,
    })),
]);
const MediaLinkLegacy = new t.Type("MediaLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.MediaLinkType, (mediaLink) => {
    return (0, function_1.pipe)(mediaLinkLegacyCodec.decode(mediaLink), fp_ts_1.either.map((parsedMediaLink) => {
        return exports.MediaLinkContent.encode({
            ...parsedMediaLink,
            __TYPE__: exports.MediaLinkType,
        });
    }));
}, (mediaLink) => {
    return mediaLinkLegacyCodec.encode(mediaLink);
});
exports.MediaLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.MediaLinkType),
    }),
    mediaLinkLegacyCodec,
]);
// DocumentLink.
exports.DocumentLinkType = "DocumentLink";
const filledDocumentLinkLegacyCodec = t.strict({
    id: validators_1.NonEmptyString,
});
const FilledDocumentLinkLegacy = new t.Type("FilledDocumentLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.DocumentLinkType, (doc) => {
    return (0, function_1.pipe)(filledDocumentLinkLegacyCodec.decode(doc), fp_ts_1.either.map((parsedDoc) => {
        return exports.FilledDocumentLinkContent.encode({
            ...parsedDoc,
            __TYPE__: exports.DocumentLinkType,
        });
    }));
}, (doc) => {
    return filledDocumentLinkLegacyCodec.encode(doc);
});
exports.FilledDocumentLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.DocumentLinkType),
    }),
    filledDocumentLinkLegacyCodec,
]);
const documentLinkLegacyCodec = t.intersection([
    t.union([
        filledDocumentLinkLegacyCodec,
        t.strict({
            kind: t.literal("document"),
        }),
    ]),
    t.exact(t.partial({
        text: t.string,
    })),
]);
const DocumentLinkLegacy = new t.Type("DocumentLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.DocumentLinkType, (file) => {
    return (0, function_1.pipe)(documentLinkLegacyCodec.decode(file), fp_ts_1.either.map((parsedDoc) => {
        return exports.DocumentLinkContent.encode({
            ...parsedDoc,
            __TYPE__: exports.DocumentLinkType,
        });
    }));
}, (doc) => {
    return documentLinkLegacyCodec.encode(doc);
});
exports.DocumentLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.DocumentLinkType),
    }),
    documentLinkLegacyCodec,
]);
// ExternalLink.
exports.ExternalLinkType = "ExternalLink";
const filledExternalLinkLegacyCodec = t.exact(t.intersection([
    t.type({
        url: t.string,
    }),
    t.partial({
        kind: t.literal("web"),
        target: validators_1.StringOrNull,
        preview: (0, function_2.nullable)(t.partial({
            title: t.string,
        })),
    }),
]));
const FilledExternalLinkLegacy = new t.Type("FilledExternalLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.ExternalLinkType, (link) => {
    return (0, function_1.pipe)(filledExternalLinkLegacyCodec.decode(link), fp_ts_1.either.map((parsedLink) => {
        return exports.FilledExternalLinkContent.encode({
            ...parsedLink,
            __TYPE__: exports.ExternalLinkType,
        });
    }));
}, (link) => {
    return filledExternalLinkLegacyCodec.encode(link);
});
exports.FilledExternalLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.ExternalLinkType),
    }),
    filledExternalLinkLegacyCodec,
]);
const externalLinkLegacyCodec = t.intersection([
    t.union([
        filledExternalLinkLegacyCodec,
        t.strict({
            kind: t.literal("web"),
        }),
    ]),
    t.exact(t.partial({
        text: t.string,
    })),
]);
const ExternalLinkLegacy = new t.Type("ExternalLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.ExternalLinkType, (file) => {
    return (0, function_1.pipe)(externalLinkLegacyCodec.decode(file), fp_ts_1.either.map((parsedLink) => {
        return exports.ExternalLinkContent.encode({
            ...parsedLink,
            __TYPE__: exports.ExternalLinkType,
        });
    }));
}, (link) => {
    return externalLinkLegacyCodec.encode(link);
});
exports.ExternalLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.ExternalLinkType),
    }),
    externalLinkLegacyCodec,
]);
// AnyLink.
exports.AnyLinkType = "AnyLink";
const anyLinkLegacyCodec = t.exact(t.intersection([
    t.type({
        kind: (0, io_ts_types_1.withFallback)(t.literal("any"), "any"),
    }),
    t.partial({
        text: t.string,
    }),
]));
const AnyLinkLegacy = new t.Type("AnyLink", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.AnyLinkType, (anyLink) => {
    return (0, function_1.pipe)(anyLinkLegacyCodec.decode(anyLink), fp_ts_1.either.map((parsedAnyLink) => {
        return exports.AnyLinkContent.encode({
            ...parsedAnyLink,
            __TYPE__: exports.AnyLinkType,
        });
    }));
}, (anyLink) => {
    return anyLinkLegacyCodec.encode(anyLink);
});
exports.AnyLinkContent = t.intersection([
    t.strict({
        __TYPE__: t.literal(exports.AnyLinkType),
    }),
    anyLinkLegacyCodec,
]);
// Link.
exports.LinkContentType = "LinkContent";
const isLinkContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.LinkContentType;
exports.isLinkContent = isLinkContent;
exports.LinkLegacy = withKey(t.union([
    ImageLinkLegacy,
    FileLinkLegacy,
    DocumentLinkLegacy,
    ExternalLinkLegacy,
    MediaLinkLegacy,
    AnyLinkLegacy,
]));
const LinkContentLegacy = (ctx) => new t.Type("LinkLegacy", exports.isLinkContent, (u) => {
    return (0, function_1.pipe)(exports.LinkLegacy.decode(u), fp_ts_1.either.map(({ key, ...value }) => exports.LinkContent.encode({
        __TYPE__: "LinkContent",
        key,
        value,
    })));
}, ({ key, value }) => {
    return {
        content: exports.LinkLegacy.encode({
            ...value,
            key,
        }),
        types: { [ctx.keyOfType]: "Link" },
    };
});
exports.LinkContentLegacy = LinkContentLegacy;
exports.Link = t.union([
    exports.ImageLinkContent,
    exports.FileLinkContent,
    exports.DocumentLinkContent,
    exports.ExternalLinkContent,
    exports.MediaLinkContent,
    exports.AnyLinkContent,
]);
exports.LinkContent = withKey(t.strict({
    __TYPE__: t.literal(exports.LinkContentType),
    value: exports.Link,
}));
// FilledLink.
const isFilledLinkContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.LinkContentType;
exports.isFilledLinkContent = isFilledLinkContent;
exports.FilledLinkLegacy = t.union([
    FilledImageLinkLegacy,
    FilledFileLinkLegacy,
    FilledDocumentLinkLegacy,
    FilledExternalLinkLegacy,
]);
const FilledLinkContentLegacy = (ctx) => {
    const FilledLinkLegacyWithKey = withKey(exports.FilledLinkLegacy);
    return new t.Type("FilledLinkLegacy", exports.isFilledLinkContent, (u) => {
        return (0, function_1.pipe)(FilledLinkLegacyWithKey.decode(u), fp_ts_1.either.map(({ key, ...value }) => exports.FilledLinkContent.encode({
            __TYPE__: "LinkContent",
            key,
            value,
        })));
    }, ({ key, value }) => {
        return {
            content: FilledLinkLegacyWithKey.encode({
                ...value,
                key,
            }),
            types: { [ctx.keyOfType]: "Link" },
        };
    });
};
exports.FilledLinkContentLegacy = FilledLinkContentLegacy;
exports.FilledLink = t.union([
    exports.FilledImageLinkContent,
    exports.FilledFileLinkContent,
    exports.FilledDocumentLinkContent,
    exports.FilledExternalLinkContent,
]);
exports.FilledLinkContent = withKey(t.strict({
    __TYPE__: t.literal(exports.LinkContentType),
    value: exports.FilledLink,
}));
