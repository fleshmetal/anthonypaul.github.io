import {
	type RepeatableContent,
	isRepeatableContent,
} from "@prismicio/types-internal/lib/content"
import type { Link } from "@prismicio/types-internal/lib/customtypes"
import {
	DiffChange,
	DiffOperation,
} from "@prismicio/types-internal/lib/customtypes/diff"

import type { NestableMock, Patch } from "../../Mock"
import type { MockConfig } from "../../MockConfig"
import { LinkMock } from "./Link"

export interface RepeatableMockConfig
	extends MockConfig<"Repeatable", RepeatableContent["value"]> {
	nbItems?: number
}

export const RepeatableMock: NestableMock<
	Link,
	RepeatableContent,
	RepeatableMockConfig
> = {
	generate(def: Link, config?: RepeatableMockConfig): RepeatableContent {
		return {
			__TYPE__: "RepeatableContent",
			type: def.type,
			value:
				config?.value ??
				Array(config?.nbItems ?? 1)
					.fill(null)
					.map(() => LinkMock.generate(def)),
		}
	},

	patch(
		diff: DiffChange<Link, Link>,
		_content: RepeatableContent,
		config?: RepeatableMockConfig,
	): RepeatableContent | undefined {
		switch (diff.op) {
			case DiffOperation.Removed:
				return
			case DiffOperation.Updated:
			case DiffOperation.Added:
				return this.generate(diff.value, config)
		}
	},

	applyPatch(data: Patch):
		| {
				result: RepeatableContent | undefined
		  }
		| undefined {
		if (data.diff.op === DiffOperation.Removed) return { result: undefined }

		if (data.diff.value.type !== "Link" || !data.diff.value.config?.repeat)
			return

		const result = this.patch(
			data.diff,
			isRepeatableContent(data.content) ? data.content : undefined,
			data.config?.type === "Repeatable" ? data.config : undefined,
		)
		return { result }
	},
}
