"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseRepeatableContent = exports.RepeatableLegacy = exports.isRepeatableContent = exports.RepeatableContent = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const nestable_1 = require("./nestable");
exports.RepeatableContent = t.strict({
    __TYPE__: t.literal("RepeatableContent"),
    type: t.literal("Link"),
    value: t.array(nestable_1.LinkContent),
});
exports.isRepeatableContent = exports.RepeatableContent.is;
const RepeatableLegacy = (ctx, fieldType) => {
    return new t.Type("RepeatableLegacy", exports.isRepeatableContent, (items) => {
        const parsed = (0, function_1.pipe)(t.array(t.unknown).decode(items), fp_ts_1.either.map((items) => {
            const parsedItems = items.reduce((acc, item) => {
                let result;
                switch (fieldType) {
                    case "Link":
                        result = (0, nestable_1.LinkContentLegacy)(ctx).decode(item);
                        break;
                }
                if (!result)
                    return acc;
                if ((0, Either_1.isLeft)(result))
                    return acc;
                return [...acc, result.right];
            }, []);
            return {
                value: parsedItems,
                type: fieldType,
                __TYPE__: "RepeatableContent",
            };
        }));
        return parsed;
    }, (r) => {
        const res = t.array(nestable_1.LinkContent).encode(r.value);
        const encodedItems = res.reduce((acc, item) => {
            let encoded;
            switch (item.__TYPE__) {
                case nestable_1.LinkContentType:
                    encoded = (0, nestable_1.LinkContentLegacy)(ctx).encode(item);
                    break;
            }
            if (!encoded)
                return acc;
            return [...acc, encoded];
        }, []);
        return {
            content: encodedItems.map((encodedItem) => encodedItem.content),
            types: { [ctx.keyOfType]: `Repeatable.${fieldType}` },
        };
    });
};
exports.RepeatableLegacy = RepeatableLegacy;
function traverseRepeatableContent({ path, key, apiId, model, content, }) {
    return (transform) => {
        const items = content.value.reduce((acc, fieldContent, index) => {
            const itemPath = path.concat([
                { key: index.toString(), type: "Widget" },
            ]);
            const transformedField = transform({
                path: itemPath,
                key: key,
                apiId: apiId,
                model: model,
                content: fieldContent,
            });
            // Can happen if the transform function returns undefined to filter out a field
            if (!transformedField)
                return acc;
            // If the transformed field is not a link content, we don't include it
            if (!(0, nestable_1.isLinkContent)(transformedField))
                return acc;
            return acc.concat(transformedField);
        }, []);
        return transform({
            path,
            key,
            apiId,
            model,
            content: {
                __TYPE__: content.__TYPE__,
                type: content.type,
                value: items,
            },
        });
    };
}
exports.traverseRepeatableContent = traverseRepeatableContent;
