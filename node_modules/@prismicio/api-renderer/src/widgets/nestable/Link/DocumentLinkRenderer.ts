import { type DocumentLinkContent, FilledDocumentLinkContent, LinkContent } from "@prismicio/types-internal/lib/content"

import type { LinkRendererOptions, RenderContext } from "../../../models"
import { AnyLinkDef, DocumentLinkDef, LinkRenderer } from "../../../models"
import type { DocRelation } from "../../../models/fetch"

export const BROKEN_CUSTOM_TYPE = "broken_type"

function brokenLinkV1(
	link: LinkContent & { value: DocumentLinkContent },
	options?: LinkRendererOptions,
): Record<string, unknown> {
	return {
		type: "Link.document",
		value: {
			...(!options?.omitKey && { key: link.key }),
			...(FilledDocumentLinkContent.is(link.value) && { id: link.value.id, tags: [] }),
			type: BROKEN_CUSTOM_TYPE,
			isBroken: true,
			...(link.value.text && { text: link.value.text }),
		},
	}
}

function brokenLinkV2(
	link: LinkContent & { value: DocumentLinkContent },
	def: DocumentLinkDef | AnyLinkDef,
	options?: LinkRendererOptions,
): Record<string, unknown> {
	return {
		...(!options?.omitKey && { key: link.key }),
		...(FilledDocumentLinkContent.is(link.value) && { id: link.value.id, tags: [] }),
		type: BROKEN_CUSTOM_TYPE,
		isBroken: true,
		...(def.allowText && link.value.text && { text: link.value.text }),
	}
}

const DocumentLinkRenderer: (
	ctx: RenderContext,
) => LinkRenderer<DocumentLinkDef, LinkContent & { value: DocumentLinkContent }, DocRelation, LinkRendererOptions> = (
	ctx,
) => {
	const extension = ctx.Extension
	return {
		renderV1(
			link: LinkContent & { value: DocumentLinkContent },
			fetch: DocRelation | undefined,
			options?: LinkRendererOptions,
		): unknown {
			if (!extension) return brokenLinkV1(link, options)

			//todo check fetch type
			try {
				if (FilledDocumentLinkContent.is(link.value)) {
					const linkKey = options?.omitKey ? undefined : link.key
					const id = extension.DocEncoder.encodeDocId(link.value.id, fetch?.uuid, [linkKey, link.value.text])

					return {
						type: "Link.document",
						value: extension.encoders.documentLinks.encode(id),
					}
				}

				return {
					type: "Link.document",
					value: {
						...(!options?.omitKey && { key: link.key }),
						...(link.value.text && { text: link.value.text }),
					},
				}
			} catch (e) {
				return brokenLinkV1(link, options)
			}
		},

		renderV2(
			def: DocumentLinkDef | AnyLinkDef,
			link: LinkContent & { value: DocumentLinkContent },
			fetch: DocRelation | undefined,
			options?: LinkRendererOptions,
		): unknown {
			if (!extension) return brokenLinkV2(link, def, options)

			//todo check fetch type
			try {
				const linkText = def.allowText ? link.value.text : undefined

				if (FilledDocumentLinkContent.is(link.value)) {
					const linkKey = options?.omitKey ? undefined : link.key
					const id = extension.DocEncoder.encodeDocId(link.value.id, fetch?.uuid, [linkKey, linkText])

					return extension.encoders.documentLinks.encode(id)
				}

				return {
					link_type: "Document",
					...(!options?.omitKey && { key: link.key }),
					...(linkText && { text: linkText }),
				}
			} catch (e) {
				return brokenLinkV2(link, def, options)
			}
		},

		renderMocks(
			def: DocumentLinkDef | AnyLinkDef,
			link: LinkContent & { value: DocumentLinkContent },
			options?: LinkRendererOptions,
		): unknown {
			if (FilledDocumentLinkContent.is(link.value)) {
				const type = (DocumentLinkDef.is(def) && def.customtypes[0]) || "mock"

				return {
					id: link.value.id,
					...(def.allowText && link.value.text && { text: link.value.text }),
					link_type: "Document",
					...(!options?.omitKey && { key: link.key }),
					type,
					tags: [],
					lang: "en-us",
					slug: null,
					first_publication_date: "1970-01-01T00:00:01+0000",
					last_publication_date: "1970-01-01T01:00:00+0000",
				}
			}

			return brokenLinkV2(link, def, options)
		},
	}
}

export default DocumentLinkRenderer
