"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BROKEN_CUSTOM_TYPE = void 0;
const content_1 = require("@prismicio/types-internal/lib/content");
const models_1 = require("../../../models");
exports.BROKEN_CUSTOM_TYPE = "broken_type";
function brokenLinkV1(link, options) {
    return {
        type: "Link.document",
        value: {
            ...(!(options === null || options === void 0 ? void 0 : options.omitKey) && { key: link.key }),
            ...(content_1.FilledDocumentLinkContent.is(link.value) && { id: link.value.id, tags: [] }),
            type: exports.BROKEN_CUSTOM_TYPE,
            isBroken: true,
            ...(link.value.text && { text: link.value.text }),
        },
    };
}
function brokenLinkV2(link, def, options) {
    return {
        ...(!(options === null || options === void 0 ? void 0 : options.omitKey) && { key: link.key }),
        ...(content_1.FilledDocumentLinkContent.is(link.value) && { id: link.value.id, tags: [] }),
        type: exports.BROKEN_CUSTOM_TYPE,
        isBroken: true,
        ...(def.allowText && link.value.text && { text: link.value.text }),
    };
}
const DocumentLinkRenderer = (ctx) => {
    const extension = ctx.Extension;
    return {
        renderV1(link, fetch, options) {
            if (!extension)
                return brokenLinkV1(link, options);
            //todo check fetch type
            try {
                if (content_1.FilledDocumentLinkContent.is(link.value)) {
                    const linkKey = (options === null || options === void 0 ? void 0 : options.omitKey) ? undefined : link.key;
                    const id = extension.DocEncoder.encodeDocId(link.value.id, fetch === null || fetch === void 0 ? void 0 : fetch.uuid, [linkKey, link.value.text]);
                    return {
                        type: "Link.document",
                        value: extension.encoders.documentLinks.encode(id),
                    };
                }
                return {
                    type: "Link.document",
                    value: {
                        ...(!(options === null || options === void 0 ? void 0 : options.omitKey) && { key: link.key }),
                        ...(link.value.text && { text: link.value.text }),
                    },
                };
            }
            catch (e) {
                return brokenLinkV1(link, options);
            }
        },
        renderV2(def, link, fetch, options) {
            if (!extension)
                return brokenLinkV2(link, def, options);
            //todo check fetch type
            try {
                const linkText = def.allowText ? link.value.text : undefined;
                if (content_1.FilledDocumentLinkContent.is(link.value)) {
                    const linkKey = (options === null || options === void 0 ? void 0 : options.omitKey) ? undefined : link.key;
                    const id = extension.DocEncoder.encodeDocId(link.value.id, fetch === null || fetch === void 0 ? void 0 : fetch.uuid, [linkKey, linkText]);
                    return extension.encoders.documentLinks.encode(id);
                }
                return {
                    link_type: "Document",
                    ...(!(options === null || options === void 0 ? void 0 : options.omitKey) && { key: link.key }),
                    ...(linkText && { text: linkText }),
                };
            }
            catch (e) {
                return brokenLinkV2(link, def, options);
            }
        },
        renderMocks(def, link, options) {
            if (content_1.FilledDocumentLinkContent.is(link.value)) {
                const type = (models_1.DocumentLinkDef.is(def) && def.customtypes[0]) || "mock";
                return {
                    id: link.value.id,
                    ...(def.allowText && link.value.text && { text: link.value.text }),
                    link_type: "Document",
                    ...(!(options === null || options === void 0 ? void 0 : options.omitKey) && { key: link.key }),
                    type,
                    tags: [],
                    lang: "en-us",
                    slug: null,
                    first_publication_date: "1970-01-01T00:00:01+0000",
                    last_publication_date: "1970-01-01T01:00:00+0000",
                };
            }
            return brokenLinkV2(link, def, options);
        },
    };
};
exports.default = DocumentLinkRenderer;
