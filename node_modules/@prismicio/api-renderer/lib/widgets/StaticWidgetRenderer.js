"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const content_1 = require("@prismicio/types-internal/lib/content");
const fetch_1 = require("../models/fetch");
const object_1 = require("../object");
const GroupRenderer_1 = tslib_1.__importDefault(require("./GroupRenderer"));
const RepeatableRenderer_1 = tslib_1.__importDefault(require("./RepeatableRenderer"));
const SimpleWidgetRenderer_1 = tslib_1.__importDefault(require("./SimpleWidgetRenderer"));
function extractFetchGroupIfAny(fetch) {
    if (fetch !== undefined && fetch.TYPE === fetch_1.GroupType) {
        return fetch;
    }
    else {
        return undefined;
    }
}
function extractFetchFieldIfAny(fetch) {
    if (fetch !== undefined && fetch.TYPE !== fetch_1.GroupType) {
        return fetch;
    }
    else {
        return undefined;
    }
}
function extractSimpleFieldIfAny(field) {
    if (field !== undefined && (field.TYPE === "SimpleField" || field.TYPE === "DocRelation")) {
        return field;
    }
    else {
        return undefined;
    }
}
function renderContent(def, content, fetch, renderer) {
    var _a, _b, _c, _d;
    // When def is a Link, there is a special management with the fact it can be repeated or not.
    // The custom type is always the one deciding the return type of the content.
    // If repeat is true, it will always return an array, and if repeat is false, it will always return an object.
    if (def.type === "Link") {
        // When repeat is true and existing content is repeatable, render the content as is
        if (((_a = def.config) === null || _a === void 0 ? void 0 : _a.repeat) && (0, content_1.isRepeatableContent)(content)) {
            return renderer.repeatable(def, content, extractSimpleFieldIfAny(fetch));
        }
        // When repeat is true and existing content is not repeatable, render as repeatable
        if (((_b = def.config) === null || _b === void 0 ? void 0 : _b.repeat) && (0, content_1.isLinkContent)(content)) {
            return renderer.repeatable(def, {
                __TYPE__: "RepeatableContent",
                type: def.type,
                value: [content],
            }, extractSimpleFieldIfAny(fetch));
        }
        // When repeat is false and existing content is repeatable with data, render the first item
        if (!((_c = def.config) === null || _c === void 0 ? void 0 : _c.repeat) && (0, content_1.isRepeatableContent)(content) && content.value[0]) {
            return renderer.simple(def, content.value[0], extractFetchFieldIfAny(fetch));
        }
        // When repeat is false and existing content is repeatable but empty, render the default widget
        if (!((_d = def.config) === null || _d === void 0 ? void 0 : _d.repeat) && (0, content_1.isRepeatableContent)(content)) {
            return renderer.default(def);
        }
        // When repeat is false and existing content is not repeatable, render the content as is,
        // using the normal nestable content renderer condition bellow
    }
    if (def.type !== "Group" && (0, content_1.isNestableContent)(content)) {
        return renderer.simple(def, content, extractFetchFieldIfAny(fetch));
    }
    if (def.type === "Group" && (0, content_1.isGroupContent)(content)) {
        return renderer.group(def, content, extractFetchGroupIfAny(fetch));
    }
    return renderer.default(def);
}
const StaticWidgetRenderer = (ctx) => (0, object_1.withObjectRenderers)({
    renderV1(content, fetch) {
        if ((0, content_1.isGroupContent)(content)) {
            return (0, GroupRenderer_1.default)(ctx).renderV1(content, extractFetchGroupIfAny(fetch));
        }
        else if ((0, content_1.isRepeatableContent)(content)) {
            return (0, RepeatableRenderer_1.default)(ctx).renderV1(content, extractSimpleFieldIfAny(fetch));
        }
        else {
            return (0, SimpleWidgetRenderer_1.default)(ctx).renderV1(content, extractFetchFieldIfAny(fetch));
        }
    },
    renderV2(def, content, fetch) {
        return renderContent(def, content, fetch, {
            group: (def, content, fetch) => (0, GroupRenderer_1.default)(ctx).renderV2(def, content, fetch),
            repeatable: (def, content, fetch) => (0, RepeatableRenderer_1.default)(ctx).renderV2(def, content, fetch),
            simple: (def, content, fetch) => (0, SimpleWidgetRenderer_1.default)(ctx).renderV2(def, content, fetch),
            default: (def) => this.renderDefault(def),
        });
    },
    renderDefault(def) {
        var _a;
        if (def.type === "Link" && ((_a = def.config) === null || _a === void 0 ? void 0 : _a.repeat)) {
            return (0, RepeatableRenderer_1.default)(ctx).renderDefault(def);
        }
        else if (def.type === "Group") {
            return (0, GroupRenderer_1.default)(ctx).renderDefault(def);
        }
        else {
            return (0, SimpleWidgetRenderer_1.default)(ctx).renderDefault(def);
        }
    },
    renderMocks(def, content) {
        return renderContent(def, content, undefined, {
            group: (def, content) => (0, GroupRenderer_1.default)(ctx).renderMocks(def, content),
            repeatable: (def, content) => (0, RepeatableRenderer_1.default)(ctx).renderMocks(def, content),
            simple: (def, content) => (0, SimpleWidgetRenderer_1.default)(ctx).renderMocks(def, content),
            default: (def) => this.renderDefault(def),
        });
    },
});
exports.default = StaticWidgetRenderer;
